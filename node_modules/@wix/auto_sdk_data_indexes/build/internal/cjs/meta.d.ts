import { CreateIndexRequest as CreateIndexRequest$1, CreateIndexResponse as CreateIndexResponse$1, DropIndexRequest as DropIndexRequest$1, DropIndexResponse as DropIndexResponse$1, ListIndexesRequest as ListIndexesRequest$1, ListIndexesResponse as ListIndexesResponse$1, ListAvailableIndexesRequest as ListAvailableIndexesRequest$1, ListAvailableIndexesResponse as ListAvailableIndexesResponse$1 } from './index.typings.js';
import '@wix/sdk-types';

/** An index is a map of a collection's data, organized according to specific fields to increase query speed. */
interface Index {
    /**
     * Name of the index.
     * @minLength 1
     * @maxLength 128
     */
    name?: string;
    /**
     * Fields for which the index is defined.
     *
     * Max: 3 fields (for a unique index: 1 field)
     * @minSize 1
     * @maxSize 3
     */
    fields?: Field[];
    /**
     * Current status of the index.
     * @readonly
     */
    status?: StatusWithLiterals;
    /**
     * Contains details about the reasons for failure when `status` is `FAILED`.
     * @readonly
     */
    failure?: Failure;
    /**
     * Whether the index enforces uniqueness of values in the field for which it is defined.
     * If `true`, the index can have only one field.
     *
     * Default: `false`
     */
    unique?: boolean;
    /**
     * Whether the index ignores case.
     *
     * Default: `false`
     */
    caseInsensitive?: boolean;
    /** Specifies the origin of the index definition. */
    source?: IndexSourceWithLiterals;
}
/**
 * Order determines how values are ordered in the index. This is important when
 * ordering and/or range querying by indexed fields.
 */
declare enum Order {
    ASC = "ASC",
    DESC = "DESC"
}
/** @enumType */
type OrderWithLiterals = Order | 'ASC' | 'DESC';
interface Field {
    /**
     * Path of the field to index. For example: `title` or `options.price`.
     * @minLength 1
     * @maxLength 128
     */
    path?: string;
    /**
     * Sort order for the index. Base on how the data is regularly queried.
     *
     * Default: `ASC`
     */
    order?: OrderWithLiterals;
}
declare enum Status {
    /** Place holder. Never returned by the service. */
    UNKNOWN = "UNKNOWN",
    /** Index creation is in progress. */
    BUILDING = "BUILDING",
    /** Index has been successfully created and can be used in queries. */
    ACTIVE = "ACTIVE",
    /** Index is in the process of being dropped. */
    DROPPING = "DROPPING",
    /** Index has been dropped successfully. */
    DROPPED = "DROPPED",
    /** Index creation has failed. */
    FAILED = "FAILED",
    /** Index contains incorrectly indexed data. */
    INVALID = "INVALID"
}
/** @enumType */
type StatusWithLiterals = Status | 'UNKNOWN' | 'BUILDING' | 'ACTIVE' | 'DROPPING' | 'DROPPED' | 'FAILED' | 'INVALID';
interface Failure {
    /**
     * Error code.
     * - `WDE0112`: Unknown error while building collection index.
     * - `WDE0113`: Duplicate key error while building collection index.
     * - `WDE0114`: Document too large while building collection index.
     * @maxLength 7
     */
    code?: string;
    /**
     * Description of the failure.
     * @maxLength 1024
     */
    description?: string;
    /**
     * ID of the data item that caused the failure.
     * For example, if `unique` is `true`, the ID of an item containing a duplicate value.
     * @maxLength 16000
     */
    itemId?: string | null;
}
declare enum IndexSource {
    /** Place holder. Never returned by the service. */
    UNKNOWN_INDEX_SOURCE = "UNKNOWN_INDEX_SOURCE",
    /** Index is created by the system, present for all collections. */
    SYSTEM = "SYSTEM",
    /** Index was created by a user via API or UI. */
    USER = "USER",
    /** Index is created automatically by the system based on user queries. */
    AUTO = "AUTO"
}
/** @enumType */
type IndexSourceWithLiterals = IndexSource | 'UNKNOWN_INDEX_SOURCE' | 'SYSTEM' | 'USER' | 'AUTO';
interface CreateIndexRequest {
    /** Details of the index to be created. */
    index: Index;
    /**
     * ID of the data collection for which to generate the index.
     * @maxLength 256
     */
    dataCollectionId: string;
}
interface CreateIndexResponse {
    /** Details of the index being generated. */
    index?: Index;
}
interface DropIndexRequest {
    /**
     * Name of the index to drop.
     * @minLength 1
     * @maxLength 128
     */
    indexName: string;
    /**
     * ID of the data collection for which the index to be dropped is defined.
     * @maxLength 1024
     */
    dataCollectionId: string;
}
interface DropIndexResponse {
}
interface ListIndexesRequest {
    /**
     * ID of the data collection for which to list indexes.
     * @maxLength 1024
     */
    dataCollectionId: string;
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface ListIndexesResponse {
    /** List of all indexes for the requested data collection. */
    indexes?: Index[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadata;
}
interface PagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
interface ListAvailableIndexesRequest {
    /**
     * Data collection to show available indexes for
     * @maxLength 256
     */
    dataCollectionId: string;
}
interface ListAvailableIndexesResponse {
    /**
     * limit of regular single-field indexes, even if 0 1-field indices may be created using
     * 3-field quota (if available)
     */
    regular1Field?: number;
    /** limit of regular indexes up to 3-fields (in addition to 1-field indexes quota) */
    regular3Field?: number;
    /** limit of unique indexes */
    unique1Field?: number;
    /** Overall index limit, missing value means there's no overall limit */
    total?: number | null;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createIndex(): __PublicMethodMetaInfo<'POST', {}, CreateIndexRequest$1, CreateIndexRequest, CreateIndexResponse$1, CreateIndexResponse>;
declare function dropIndex(): __PublicMethodMetaInfo<'DELETE', {}, DropIndexRequest$1, DropIndexRequest, DropIndexResponse$1, DropIndexResponse>;
declare function listIndexes(): __PublicMethodMetaInfo<'GET', {}, ListIndexesRequest$1, ListIndexesRequest, ListIndexesResponse$1, ListIndexesResponse>;
declare function listAvailableIndexes(): __PublicMethodMetaInfo<'GET', {}, ListAvailableIndexesRequest$1, ListAvailableIndexesRequest, ListAvailableIndexesResponse$1, ListAvailableIndexesResponse>;

export { type __PublicMethodMetaInfo, createIndex, dropIndex, listAvailableIndexes, listIndexes };
