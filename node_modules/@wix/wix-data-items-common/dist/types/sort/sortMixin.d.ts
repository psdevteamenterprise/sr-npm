import { AggregatingValidator } from '../errors';
export type Direction = 'asc' | 'desc';
export interface OrderBySpec {
    [field: string]: Direction;
}
export type OrderBy = OrderBySpec[];
interface WithConstructor {
    new (...args: any): any;
}
declare const sortMixin: (Base?: WithConstructor) => {
    new (obj?: any): {
        [x: string]: any;
        orderBy: OrderBy;
        invalidArguments: string[];
        ascending(...fields: any[]): any;
        descending(...fields: any[]): any;
        getSortModel(): OrderBy;
        setSortModel(sortModel: any[]): any;
        _sortClause(operatorSymbol: Direction, operatorName: string, args: any[]): any;
        _sortValidator(operatorName: string): SortValidator;
        _copySort(orderBy: OrderBy, invalidArguments: string[]): any;
    };
};
export declare class SortValidator extends AggregatingValidator {
    operatorName: string;
    constructor(operatorName: string, previousInvalidArguments: string[]);
    allStrings(effectiveArgs: any[]): this;
}
declare const Sort_base: {
    new (obj?: any): {
        [x: string]: any;
        orderBy: OrderBy;
        invalidArguments: string[];
        ascending(...fields: any[]): any;
        descending(...fields: any[]): any;
        getSortModel(): OrderBy;
        setSortModel(sortModel: any[]): any;
        _sortClause(operatorSymbol: Direction, operatorName: string, args: any[]): any;
        _sortValidator(operatorName: string): SortValidator;
        _copySort(orderBy: OrderBy, invalidArguments: string[]): any;
    };
};
export declare class Sort extends Sort_base {
}
export default sortMixin;
//# sourceMappingURL=sortMixin.d.ts.map