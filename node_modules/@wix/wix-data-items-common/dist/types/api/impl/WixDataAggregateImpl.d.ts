import { PlatformizedFilterBuilder } from '../../filter';
import { QueryBase } from '../QueryBase';
import { Sort } from '../../sort/sortMixin';
import { WixDataResult } from '../WixDataResult';
import { WixDataAggregateOptions } from '../types';
import { WixDataAggregate } from '../WixDataAggregate';
interface Aggregate {
    name: string;
    avg?: string;
    min?: string;
    max?: string;
    sum?: string;
    count?: true;
}
interface AggregateParams {
    collectionName: string;
    invalidArguments: string[];
    filterTree?: Record<string, any>;
    havingTree?: Record<string, any>;
    aggregates: Aggregate[];
    groupBy: string[];
    limitNumber?: number;
    skipNumber: number;
    orderBy: {
        [field: string]: 'asc' | 'desc';
    }[];
}
type OnRun = (args: IArguments, params: AggregateParams, options?: WixDataAggregateOptions) => Promise<WixDataResult<Record<string, any>>>;
export declare class WixDataAggregateImpl extends QueryBase<WixDataAggregateImpl> implements WixDataAggregate {
    readonly limitNumber?: number;
    readonly skipNumber: number;
    readonly aggregates: Aggregate[];
    readonly groupBy: string[];
    private readonly havingBuilder?;
    private readonly onRun;
    private readonly ownInvalidArguments;
    constructor(origin: {
        collectionName: string;
        filter?: PlatformizedFilterBuilder;
        invalidArguments?: string[];
        sort?: Sort;
        limitNumber?: number;
        skipNumber?: number;
        aggregates?: Aggregate[];
        groupBy?: string[];
        havingBuilder?: PlatformizedFilterBuilder;
        onRun: OnRun;
    });
    protected copy(params: {
        limitNumber?: number;
        skipNumber?: number;
        addAggregates?: Aggregate[];
        groupBy?: string[];
        havingBuilder?: PlatformizedFilterBuilder;
        filterBuilder?: PlatformizedFilterBuilder;
        sort?: Sort;
        invalidArguments?: string[];
    }): WixDataAggregateImpl;
    get invalidArguments(): string[];
    run(options?: WixDataAggregateOptions): Promise<WixDataResult<Record<string, any>>>;
    private addAggregate;
    sum(fieldName: string, projectedField?: string): WixDataAggregate;
    avg(fieldName: string, projectedField?: string): WixDataAggregate;
    min(fieldName: string, projectedField?: string): WixDataAggregate;
    max(fieldName: string, projectedField?: string): WixDataAggregate;
    count(projectedField?: string): WixDataAggregate;
    filter(filterBuilder: PlatformizedFilterBuilder): WixDataAggregate;
    group(...fieldName: string[]): WixDataAggregate;
    having(filterBuilder: PlatformizedFilterBuilder): WixDataAggregate;
    get havingTree(): Record<string, any>;
    limit(limitNumber: number): WixDataAggregateImpl;
    skip(skipNumber: number): WixDataAggregateImpl;
    private aggregateValidator;
}
export {};
//# sourceMappingURL=WixDataAggregateImpl.d.ts.map