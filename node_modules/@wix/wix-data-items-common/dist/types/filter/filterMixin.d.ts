import { AggregatingValidator } from '../errors/base-validator';
import { Validator } from '@wix/filter-builder';
declare const filterMixin: (Base?: any) => {
    new (origin?: {
        validateCollectionName?: boolean;
        filterTree?: object;
        invalidArguments?: string[];
        encoder?: Function;
    }): {
        [x: string]: any;
        readonly validateCollectionName: boolean;
        or(otherQuery: any): any;
        and(otherQuery: any): any;
        not(otherQuery: any): any;
        _validateCollectionName(query: any, originalQuery: any, operationName: string): any;
        _matchesUrlized(field: any, operand: any): any;
        getFilterModel(): any;
        _filterValidator(filterOperatorName: string): Validator;
        filterTree: any;
        invalidArguments: any;
        encoder: any;
        eq(...args: any[]): any;
        ne(...args: any[]): any;
        ge(...args: any[]): any;
        gt(...args: any[]): any;
        le(...args: any[]): any;
        lt(...args: any[]): any;
        isNotEmpty(field: any): any;
        isEmpty(field: any): any;
        startsWith(...args: any[]): any;
        endsWith(...args: any[]): any;
        contains(...args: any[]): any;
        hasSome(...args: any[]): any;
        hasAll(...args: any[]): any;
        between(field: any, rangeStart: any, rangeEnd: any): any;
        setFilterModel(filterModel: any): any;
        _binaryAnd(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndLogicalEquivalence(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndStringOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _AndSetOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _makeNewFilter(field: any, filterOperatorName: any, operand: any): any;
        _buildFilter(field: any, filterOperatorName: any, operand: any): {};
        _encode(operand: any): any;
        _copy(filterTree: any, invalidArguments: any): any;
    };
};
export declare class FilterValidator extends AggregatingValidator {
    operatorName: string;
    private ctor;
    private constructorName;
    constructor(operatorName: string, previousInvalidArguments: string[], ctor: any, constructorName: string);
    typeIsString(value: any): this;
    typeIsStringNumberOrDate(value: any): this;
    sameType(first: any, second: any): this;
    typeIsStringNumberOrDateForAll(values: any): this;
    validFieldName(field: any): this;
    isInstanceOfSameClass(obj: any): this;
    isForCollection(otherFilterBuilder: any, expectedCollectionName: any): this;
}
export default filterMixin;
//# sourceMappingURL=filterMixin.d.ts.map