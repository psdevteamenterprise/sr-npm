type Comparable = string | number | Date;
/**
 * Type that allow filter construction.
 * All construction methods return copy of self
 */
export default interface WithFilter<Self extends WithFilter<Self>> {
    /**
     * Filter JSON, possibly invalid
     * @internal
     */
    readonly filterTree: Record<string, any>;
    /**
     * Validation errors, if empty filterTree is valid
     * @internal
     */
    readonly invalidArguments: string[];
    /**
     * Refines a query or filter to match items whose specified property value equals the specified value.
     *
     * The `eq()` function refines this filter to only
     * match items where the value of the specified property equals the specified `value`.
     *
     * It only matches values of the same type. For example, a number value stored
     * as a String type does not match the same number stored as a Number type.
     *
     * Matching strings with `eq()` is case sensitive, so `"text"` is not equal to `"Text"`.
     *
     * If `field` points to a collection field of type Array, `eq()` includes the item
     * as long as at least one Array element matches the specified `value`.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param value - The value to match against.
     * @requiredField value
     * @returns An object representing the refined query.
     */
    eq(field: string, value: any): Self;
    /**
     * Refines a query or filter to match items whose specified property value does not equal the specified value.
     *
     * The `ne()` function refines this filter to only
     * match items where the value of the specified property does not equal the specified `value`.
     *
     * It only matches values of the same type. For example, a number value stored
     * as a String type is considered not equal to the same number stored as a Number type.
     *
     * Matching strings with `ne()` is case sensitive, so `"text"` is not equal to `"Text"`.
     *
     * If the value of the `field` property is an Array, `ne()` includes items
     * in which none of the elements of the Array match the specified `value`.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param value - The value to match against.
     * @requiredField value
     * @returns An object representing the refined query.
     */
    ne(field: string, value: any): Self;
    /**
     * Refines a query or filter to match items whose specified property value is greater than or equal to the specified
     * value.
     *
     * The `ge()` function refines this filter to only
     * match items where the value of the specified property is greater than or
     * equal to the specified `value`.
     *
     * It only matches values of the same type. For example, a number value stored
     * as a String type does not match the same number stored as a Number type.
     *
     * If a property contains a number as a String, that value will be compared
     * alphabetically and not numerically. Items that do not have a value for the
     * specified property are ranked lowest.
     *
     * The following types of properties can be compared:
     * - Number: Compares numerically.
     * - Date: Compares JavaScript Date objects.
     * - String: Compares lexicographically,
     *   so `"abc"` is greater than or equal to `"ABC"` (because of the greater than),
     *   but `"ABC"` is not greater than or equal to `"abc"`.
     * - Reference: Compares by the ID of the referenced item as a String.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param value - The value to match against.
     * @requiredField value
     * @returns An object representing the refined query.
     */
    ge(field: string, value: Comparable): Self;
    /**
     * Alias for `ge()`
     * @internal
     */
    gte(field: string, value: Comparable): Self;
    /**
     * Refines a query or filter to match items whose specified property value is greater than the specified value.
     *
     * The `gt()` function refines this filter to only match
     * items where the value of the specified property is greater than the specified `value`.
     *
     * It only matches values of the same type. For example, a number value stored
     * as a String type does not match the same number stored as a Number type.
     *
     * If a property contains a number as a String, that value will be compared
     * alphabetically and not numerically. Items that do not have a value for the
     * specified property are ranked lowest.
     *
     * The following types of properties can be compared:
     * - Number: Compares numerically.
     * - Date: Compares JavaScript Date objects.
     * - String: Compares lexicographically, so `"text"` is greater than `"Text"`.
     * - Reference: Compares by the ID of the referenced item as a String.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param value - The value to match against.
     * @requiredField value
     * @returns An object with the query definition, based on the supplied parameters.
     */
    gt(field: string, value: Comparable): Self;
    /**
     * Refines a query or filter to match items whose specified property value is less than or equal to the specified
     * value.
     *
     * The `le()` function refines this filter to only match
     * items where the value of the specified property is less than or equal to the
     * specified `value`.
     *
     * It only matches values of the same type. For example, a number value stored
     * as a String type does not match the same number stored as a Number type.
     *
     * If a property contains a number as a String, that value will be compared
     * alphabetically and not numerically. Items that do not have a value for the
     * specified property are ranked lowest.
     *
     * The following types of properties can be compared:
     * - Number: Compares numerically.
     * - Date: Compares JavaScript Date objects.
     * - String: Compares lexicographically,
     *   so `"ABC"` is less than or equal to `"abc"` (because of the less than),
     *   but `"abc"` is not less than or equal to `"ABC"`.
     * - Reference: Compares by the ID of the referenced item as a String.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param value - The value to match against.
     * @requiredField value
     * @returns An object representing the refined query.
     */
    le(field: string, value: Comparable): Self;
    /**
     * Alias for `le()`
     * @internal
     */
    lte(field: string, value: Comparable): Self;
    /**
     * Refines a query or filter to match items whose specified property value is less than the specified value.
     *
     * The `lt()` function refines this filter to only match
     * items where the value of the specified property is less than the specified `value`.
     *
     * It only matches values of the same type. For example, a number value stored
     * as a String type does not match the same number stored as a Number type.
     *
     * If a property contains a number as a String, that value will be compared
     * alphabetically and not numerically. Items that do not have a value for the
     * specified property are ranked lowest.
     *
     * The following types of properties can be compared:
     * - Number: Compares numerically.
     * - Date: Compares JavaScript Date objects.
     * - String: Compares lexicographically, so `"Text"` is less than `"text"`.
     * - Reference: Compares by the ID of the referenced item as a String.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param value - The value to match against.
     * @requiredField value
     * @returns An object with the query definition, based on the supplied parameters.
     */
    lt(field: string, value: Comparable): Self;
    /**
     * Refines a query or filter to match items whose specified property has any value.
     *
     * The `isNotEmpty()` function refines this filter to only match items where the
     * value of the specified property is not `null` or `undefined`.
     *
     * If the property contains any value at all for a given item, including the
     * empty string or an invalid value, that item will match the query.
     * @public
     * @documentationMaturity preview
     * @param field - The property in which to check for a value.
     * @requiredField field
     * @returns An object representing the refined query.
     */
    isNotEmpty(field: string): Self;
    /**
     * Refines a query or filter to match items whose specified property does not exist or does not have any value.
     *
     * The `isEmpty()` function refines this filter to only match items where the
     * value of the specified property is `null` or `undefined` or the property does
     * not exist.
     *
     * If the property contains any value at all for a given item, including the
     * empty string or an invalid value, that item will match the query.
     * @public
     * @documentationMaturity preview
     * @param field - The property in which to check for a value.
     * @requiredField field
     * @returns An object representing the refined query.
     */
    isEmpty(field: string): Self;
    /**
     * Refines a query or filter to match items whose specified property value starts with a specified string.
     *
     * The `startsWith()` function refines this filter to
     * only match items where the value of the specified property starts with the
     * defined `string`. Matching with `startsWith()` is not case sensitive, so `"TEXT"` starts
     * with `"tex"`.
     *
     * You can only use `startsWith()` with a property whose value is a String or Reference.
     * When using a Reference, `startsWith()` matches by the ID of the referenced item as Strings.
     * @public
     * @documentationMaturity preview
     * @param field - Property whose value will be compared with the `value` parameter.
     * @requiredField field
     * @param value - String to look for at the beginning of the specified property value.
     * @requiredField value
     * @returns `WixDataQuery` object representing the refined query.
     */
    startsWith(field: string, value: string): Self;
    /**
     * Refines a query or filter to match items whose specified property value ends with a specified string.
     *
     * The `endsWith()` function refines this filter to only
     * match items where the value of the specified property ends with the specified
     * `string`. Matching with `endsWith()` is not case sensitive, so `"TEXT"` ends
     * with `"ext"`.
     *
     * You can only use `endsWith()` with a property whose value is a String or Reference.
     * When using a Reference, `endsWith()` matches by the ID of the referenced item as Strings.
     * @public
     * @documentationMaturity preview
     * @param field - Property whose value will be compared with the string.
     * @requiredField field
     * @param value - String to look for at the end of the specified property value.
     * @requiredField value
     * @returns `WixDataQuery` object representing the refined query.
     */
    endsWith(field: string, value: string): Self;
    /**
     * Refines a query or filter to match items whose specified property value contains a specified string.
     *
     * The `contains()` function refines this filter to
     * only match items where the value of the specified property contains the
     * specified `string`. Matching with `contains()` is not case sensitive, so
     * `"text"` does contain `"Tex"`.
     *
     * You can use `contains()` with a property whose value is a String or a Reference.
     * For properties of type reference it is recommended that you use the [`eq()`](#eq)
     * function instead of `contains()`. With properties that are References, `contains()`
     * matches by the ID of the referenced item as a String.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with the string.
     * @requiredField field
     * @param value - The string to look for inside the specified property value.
     * @requiredField value
     * @returns An object representing the refined query.
     */
    contains(field: string, value: string): Self;
    /**
     * Refines a query or filter to match items whose specified property value equals any of the specified `values`
     * parameters.
     *
     * The `hasSome()` function refines this filter to
     * only match items where the value of the specified property equals any of
     * the specified values.
     *
     * Matching strings with `hasSome()` is case sensitive, so `"text"` is not equal to `"Text"`.
     *
     * If the value of the specified property is an array, `hasSome()` will match
     * if any of the elements of that array match any of the specified values.
     *
     * If the specified property contains multiple references, pass item IDs in the
     * `value` property. In such a case, `hasSome()` will match if any of the
     * multiple references match any of the specified ID values.
     *
     * You can specify a list of values to match by providing an array of
     * String, Number, or Date types as the `value` parameters.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param values - The values to match against.
     * @requiredField values
     * @returns An object representing the refined query.
     */
    hasSome(field: string, ...values: Comparable[]): Self;
    /**
     * Overload for `hasSome()`
     * @public
     * @documentationMaturity preview
     */
    hasSome(field: string, values: Comparable[]): Self;
    /**
     * Alias for `hasSome()`
     * @internal
     */
    in(field: string, ...values: Comparable[]): Self;
    /**
     * Alias for `hasSome()`
     * @internal
     */
    in(field: string, values: Comparable[]): Self;
    /**
     * Refines a query or filter to match items whose specified property values equals all of the specified `value`
     * parameters.
     *
     * The `hasAll()` function refines this filter to
     * only match items where the value of the specified property equals all of
     * the specified values.
     *
     * Matching strings with `hasAll()` is case sensitive, so `"text"` is not equal to `"Text"`.
     *
     * If the value of the specified property is an array, `hasAll()` will match
     * if there is a match in the elements of that array for all of the specified
     * values.
     *
     * You can specify a list of values to match by providing an array of
     * String, Number, or Date types as the `value` parameters.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with `value`.
     * @requiredField field
     * @param values - The values to match against.
     * @requiredField values
     * @returns An object representing the refined query.
     */
    hasAll(field: string, ...values: Comparable[]): Self;
    /**
     * Overload for `hasAll()`
     * @public
     * @documentationMaturity preview
     */
    hasAll(field: string, values: Comparable[]): Self;
    /**
     * Exists filter.
     * @returns `current $and (field $exists value)`
     * @internal
     */
    exists(field: string, value: boolean): Self;
    /**
     * Adds an `or` condition to the query or filter.
     *
     * The `or()` function adds an inclusive `or` condition to this filter. A query or filter
     * with an `or` returns all the items that match the query or filter as defined up to
     * the `or` function, the items that match the query or filter passed to the `or`
     * function, and the items that match both.
     *
     * The collections used by both the initial query and the query passed
     * to the `or` function must be the same.
     *
     * The 'or()' function is designed to work with 2 or more queries or filters.
     * If you use it on its own, it will return all the items in a collection.
     * @public
     * @documentationMaturity preview
     * @param filter - Filter to add to the initial filter as an `or` condition.
     * @requiredField filter
     * @returns Object representing the refined query.
     */
    or(filter: WithFilter<any>): Self;
    /**
     * Adds an `and` condition to the query or filter.
     *
     * The `and()` function adds an and condition to this query. A query or filter with an `and` returns all the items
     * that match the query or filter as defined up to the `and` function and also match the query or filter passed to
     * the `and` function.
     *
     * Note that when chaining multiple `WixDataFilter` functions to a query an and condition is assumed. In such cases,
     * you do not need to add a call to the `and()` function. For example, this query returns results where status is
     * active **and** age is greater than 25.
     * ```js
     * wixData.query("myCollection").eq("status", "active").gt("age", 25);
     * ```
     *
     * The `and()` function is needed when performing compound queries. For example, the final query in this set of
     * queries returns results where status is either pending or rejected **and** age is either less than 25 or greater
     * than 65.
     * ```js
     * let statusQuery = wixData
     *   .query("myCollection")
     *   .eq("status", "pending")
     *   .or(wixData.query("myCollection").eq("status", "rejected"));
     *
     * let ageQuery = wixData
     *   .query("myCollection")
     *   .lt("age", 25)
     *   .or(wixData.query("myCollection").gt("age", 65));
     *
     * let statusAndAgeQuery = statusQuery.and(ageQuery);
     * ```
     *
     * The collections referenced by both the initial query and the query passed to the `and` function must be the same.
     *
     * The `and()` function is designed to work with 2 or more queries or filters. If you use it on its own, it will
     * return all the items in a collection.
     * @public
     * @documentationMaturity preview
     * @param filter - A filter to add to the initial query as an `and` condition.
     * @requiredField filter
     * @returns An object representing the refined query.
     */
    and(filter: WithFilter<any>): Self;
    /**
     * Adds a `not` condition to the query or filter.
     *
     * The `not()` function adds a `not` condition to this filter. A query or filter with a `not`
     * returns all the items that match the query or filter as defined up to the `not`
     * function, but don't match the query or filter passed to the `not` function.
     *
     * If the query or filter only contains a `not()` function, it returns all the items
     * that don't match the query defined by the `not` method.
     *
     * The collections referenced by both the initial query and the query passed
     * to the `not` function must be the same.
     * @public
     * @documentationMaturity preview
     * @param filter - Filter to add to the initial filter as a `not` condition.
     * @requiredField filter
     * @returns Object representing the refined query.
     */
    not(filter: WithFilter<any>): Self;
    /**
     * Refines a query or filter to match items whose specified property value is within a specified range.
     *
     * The `between()` function refines this query to only match items where the value of the specified property is
     * greater than or equal to `rangeStart` and less than `rangeEnd`.
     *
     * It only matches values of the same type. For example, a number value stored as a String type does not match the
     * same number stored as a Number type.
     *
     * If a property contains a number as a String, that value will be compared alphabetically and not numerically. Items
     * that do not have a value for the specified property are ranked lowest.
     *
     * The following types of properties can be compared:
     * - Number: Compares numerically.
     * - Date: Compares JavaScript Date objects.
     * - String: Compares lexicographically, so
     *   - `"A"` and `"M"` are between `"A"` and `"Z"`, but `"a"`, `"m"`, `"z"` and `"Z"` are not.
     *   - `"A"`, `"M"`, `"Z"`, and `"a"` are between `"A"` and `"z"`, but `"z"` is not.
     * @public
     * @documentationMaturity preview
     * @param field - The property whose value will be compared with rangeStart and rangeEnd.
     * @requiredField field
     * @param rangeStart - The beginning value of the range to match against.
     * @requiredField rangeStart
     * @param rangeEnd - The ending value of the range to match against.
     * @requiredField rangeEnd
     * @returns An object representing the refined query.
     */
    between<T extends Comparable>(field: string, rangeStart: T, rangeEnd: T): Self;
}
export {};
//# sourceMappingURL=WithFilter.d.ts.map