import WithFilter from './WithFilter';
declare const FilterBuilder_base: {
    new (origin?: {
        validateCollectionName?: boolean | undefined;
        filterTree?: object | undefined;
        invalidArguments?: string[] | undefined;
        encoder?: Function | undefined;
    } | undefined): {
        [x: string]: any;
        readonly validateCollectionName: boolean;
        or(otherQuery: any): any;
        and(otherQuery: any): any;
        not(otherQuery: any): any;
        _validateCollectionName(query: any, originalQuery: any, operationName: string): any;
        _matchesUrlized(field: any, operand: any): any;
        getFilterModel(): any;
        _filterValidator(filterOperatorName: string): import("@wix/filter-builder").Validator;
        filterTree: any;
        invalidArguments: any;
        encoder: any;
        eq(...args: any[]): any;
        ne(...args: any[]): any;
        ge(...args: any[]): any;
        gt(...args: any[]): any;
        le(...args: any[]): any;
        lt(...args: any[]): any;
        isNotEmpty(field: any): any;
        isEmpty(field: any): any;
        startsWith(...args: any[]): any;
        endsWith(...args: any[]): any;
        contains(...args: any[]): any;
        hasSome(...args: any[]): any;
        hasAll(...args: any[]): any;
        between(field: any, rangeStart: any, rangeEnd: any): any;
        setFilterModel(filterModel: any): any;
        _binaryAnd(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndLogicalEquivalence(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndStringOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _AndSetOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _makeNewFilter(field: any, filterOperatorName: any, operand: any): any;
        _buildFilter(field: any, filterOperatorName: any, operand: any): {};
        _encode(operand: any): any;
        _copy(filterTree: any, invalidArguments: any): any;
    };
};
export declare class FilterBuilder extends FilterBuilder_base {
    get constructorName(): string;
    _build(): any;
}
declare const PlatformizedFilterBuilder_base: {
    new (origin?: {
        validateCollectionName?: boolean | undefined;
        filterTree?: object | undefined;
        invalidArguments?: string[] | undefined;
        encoder?: Function | undefined;
    } | undefined): {
        [x: string]: any;
        readonly validateCollectionName: boolean;
        or(otherQuery: any): any;
        and(otherQuery: any): any;
        not(otherQuery: any): any;
        _validateCollectionName(query: any, originalQuery: any, operationName: string): any;
        _matchesUrlized(field: any, operand: any): any;
        getFilterModel(): any;
        _filterValidator(filterOperatorName: string): import("@wix/filter-builder").Validator;
        filterTree: any;
        invalidArguments: any;
        encoder: any;
        eq(...args: any[]): any;
        ne(...args: any[]): any;
        ge(...args: any[]): any;
        gt(...args: any[]): any;
        le(...args: any[]): any;
        lt(...args: any[]): any;
        isNotEmpty(field: any): any;
        isEmpty(field: any): any;
        startsWith(...args: any[]): any;
        endsWith(...args: any[]): any;
        contains(...args: any[]): any;
        hasSome(...args: any[]): any;
        hasAll(...args: any[]): any;
        between(field: any, rangeStart: any, rangeEnd: any): any;
        setFilterModel(filterModel: any): any;
        _binaryAnd(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndLogicalEquivalence(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndStringOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _AndSetOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _makeNewFilter(field: any, filterOperatorName: any, operand: any): any;
        _buildFilter(field: any, filterOperatorName: any, operand: any): {};
        _encode(operand: any): any;
        _copy(filterTree: any, invalidArguments: any): any;
    };
};
export declare class PlatformizedFilterBuilder extends PlatformizedFilterBuilder_base implements WithFilter<PlatformizedFilterBuilder> {
    in(...args: any[]): any;
    exists(...args: any[]): any;
    gte(field: any, value: any): any;
    lte(field: any, value: any): any;
    build(): any;
    hasAnyFilter(): boolean;
}
export declare function platformizedFilterBuilder(options?: {}): PlatformizedFilterBuilder;
export declare function filterBuilderFactory(): FilterBuilder;
export default filterBuilderFactory;
//# sourceMappingURL=filterBuilder.d.ts.map