"use strict";

exports.__esModule = true;
exports.validateFilterOrThrow = validateFilterOrThrow;
exports.validateFilterTree = validateFilterTree;
var _errors = require("../errors/errors");
var _typeUtils = require("../utils/type-utils");
// [FilterTree] is old format

const {
  filterTreeValidations: errors
} = _errors.messages;
function validateFilterOrThrow(tree) {
  const failures = validateFilterTree(tree);
  if (failures.length === 0) {
    return true;
  }
  throw (0, _errors.validationError)(`Invalid filter:${failures.join('\n')}`);
}
function validateFilterTree(tree, path) {
  if (!(0, _typeUtils.isObject)(tree)) {
    return [errors.objectType('Filter Model', tree)];
  }
  const collectedErrors = [];
  for (const key of Object.keys(tree)) {
    const value = tree[key];
    const at = join(path, key);
    switch (key) {
      case '$and':
      case '$or':
        if (!(0, _typeUtils.isArray)(value)) {
          collectedErrors.push(errors.arrayType(at, value));
        }
        if ((0, _typeUtils.isArray)(value)) {
          collectedErrors.push(...value.flatMap(x => validateFilterTree(x, at)));
        }
        break;
      case '$not':
        if (!(0, _typeUtils.isArray)(value)) {
          collectedErrors.push(...validateFilterTree(value, at));
        }
        if ((0, _typeUtils.isArray)(value) && value.length !== 1) {
          collectedErrors.push(errors.arrayLength(at, 1, value));
        }
        if ((0, _typeUtils.isArray)(value) && value.length > 0) {
          collectedErrors.push(...validateFilterTree(value[0], at));
        }
        break;
      default:
        if (key.startsWith('$')) {
          collectedErrors.push(`Unexpected operator ${at}`);
        } else {
          collectedErrors.push(...validateOperatorOrValue(value, at));
        }
    }
  }
  return collectedErrors;
}
function validateOperatorOrValue(value, path) {
  if ((0, _typeUtils.isObject)(value) && !isComparableValue(value) && Object.keys(value).some(op => op.startsWith('$'))) {
    return validateOperator(value, path);
  }
  return [];
}
function validateOperator(operator, path) {
  if (!(0, _typeUtils.isObject)(operator)) {
    return [errors.objectType(path, operator)];
  }
  const collectedErrors = [];
  for (const key of Object.keys(operator)) {
    const at = join(path, key);
    const value = operator[key];
    switch (key) {
      case '$eq':
      case '$ne':
        break;
      case '$gt':
      case '$gte':
      case '$lt':
      case '$lte':
        if (!isComparableValue(value)) {
          collectedErrors.push(errors.comparisonOperatorType(at, value));
        }
        break;
      case '$startsWith':
      case '$endsWith':
      case '$contains':
        if (!(0, _typeUtils.isString)(value)) {
          collectedErrors.push(errors.stringOperatorType(at, value));
        }
        break;
      case '$exists':
        if (!(0, _typeUtils.isBoolean)(value)) {
          collectedErrors.push(`${at} should be a Boolean`);
        }
        break;
      case '$hasSome':
      case '$hasAll':
      case '$in':
        if (!(0, _typeUtils.isArray)(value)) {
          collectedErrors.push(errors.arrayType(at, value));
        }
        if ((0, _typeUtils.isArray)(value) && !value.every(isComparableValue)) {
          collectedErrors.push(errors.setOperatorItems(at, value));
        }
        break;
      case '$matches':
        if (!(0, _typeUtils.isObject)(value)) {
          collectedErrors.push(errors.objectType(at, value));
        }
        if ((0, _typeUtils.isObject)(value) && value.ignoreCase !== true) {
          collectedErrors.push(errors.matchesOperatorIgnoreCase(value));
        }
        if ((0, _typeUtils.isObject)(value) && !(0, _typeUtils.isArray)(value.spec)) {
          collectedErrors.push(errors.arrayType(`${at}.spec`, value.spec));
        }
        if ((0, _typeUtils.isArray)(value == null ? void 0 : value.spec)) {
          const validSpec = spec => {
            if (!(0, _typeUtils.isObject)(spec)) {
              return false;
            }
            if (spec.type === 'anyOf' && spec.value === ' \t\n-') {
              return true;
            }
            return spec.type === 'literal' && (0, _typeUtils.isString)(spec.value);
          };
          const invalid = value.spec.find(x => !validSpec(x));
          if (invalid !== undefined) {
            collectedErrors.push(errors.matchesOperatorSpecItems(invalid));
          }
        }
        break;
      case '$regex':
        collectedErrors.push(errors.regexNotAllowed());
        break;
      case '$not':
        collectedErrors.push(...validateOperator(value, at));
        break;
      default:
        collectedErrors.push(`Unknown operator ${at}`);
    }
  }
  return collectedErrors;
}
function isComparableValue(x) {
  if ((0, _typeUtils.isDate)(x) || (0, _typeUtils.isString)(x) || (0, _typeUtils.isNumber)(x)) {
    return true;
  }
  return (0, _typeUtils.isObject)(x) && (0, _typeUtils.isString)(x.$date) && Object.keys(x).length === 1;
}
function join(prefix, next) {
  return prefix === undefined ? next : `${prefix}.${next}`;
}
//# sourceMappingURL=FilterTree.js.map