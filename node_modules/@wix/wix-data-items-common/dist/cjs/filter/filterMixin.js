"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = exports.FilterValidator = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeUtils = require("../utils/type-utils");
var _baseValidator = require("../errors/base-validator");
var _errors = require("../errors/errors");
var _filterBuilder = require("@wix/filter-builder");
const filterMixin = (Base = class {}) => class extends (0, _filterBuilder.filterMixin)(Base) {
  constructor(origin) {
    super(origin);
    (0, _defineProperty2.default)(this, "validateCollectionName", void 0);
    this.validateCollectionName = (origin == null ? void 0 : origin.validateCollectionName) ?? true;
  }
  or(otherQuery) {
    const orQuery = super.or.apply(this, arguments);
    return this._validateCollectionName(orQuery, otherQuery, '.or');
  }
  and(otherQuery) {
    const andQuery = super.and.apply(this, arguments);
    return this._validateCollectionName(andQuery, otherQuery, '.and');
  }
  not(otherQuery) {
    const notQuery = super.not.apply(this, arguments);
    return this._validateCollectionName(notQuery, otherQuery, '.not');
  }
  _validateCollectionName(query, originalQuery, operationName) {
    if (query.invalidArguments.length > 0 || !this.validateCollectionName) {
      return query;
    }
    const withCollectionName = withCollectionNameIfUnset(originalQuery, this.collectionName);
    const [newInvalidArguments, valid] = new FilterValidator(operationName, query.invalidArguments, this.constructor, this.constructorName ?? this.constructor.name).isForCollection(withCollectionName, this.collectionName).validateAndAggregate();
    if (!valid) {
      return this._copy(this.filterTree, newInvalidArguments);
    }
    return query;
  }

  // used only from data binding router internally
  _matchesUrlized(field, operand) {
    const [newInvalidArguments, valid] = this._filterValidator('._matchesUrlized').arityIsTwo(arguments).validFieldName(field).typeIsString(operand).validateAndAggregate();
    if (valid) {
      const newFilterTree = this._makeNewFilter(field,
      // @ts-expect-error-next-line
      ...createMatchesOrInFilter(operand));
      return this._copy(newFilterTree, newInvalidArguments);
    }
    return this._copy(this.filterTree, newInvalidArguments);
  }
  getFilterModel() {
    if (this.invalidArguments.length > 0) {
      throw (0, _errors.validationError)(_errors.messages.filterBuilderInvalid(this.invalidArguments));
    }
    return super.getFilterModel();
  }
  _filterValidator(filterOperatorName) {
    return new FilterValidator(filterOperatorName, this.invalidArguments, this.constructor, this.constructorName ?? this.constructor.name);
  }
};
function createMatchesOrInFilter(operand) {
  if (looksLikeAnInteger(operand)) {
    // eslint-disable-next-line radix
    return ['$in', [operand, Number.parseInt(operand)]];
  } else {
    return ['$matches', {
      ignoreCase: true,
      spec: createMatchSpec(operand)
    }];
  }
  function looksLikeAnInteger(str) {
    return /^-?[0-9]{1,16}$/.test(str);
  }
}
function createMatchSpec(fieldValue) {
  const literals = fieldValue.split('-');
  const result = [];
  for (let i = 0; i < literals.length - 1; i++) {
    appendLiteralSegment(result, literals[i]);
    appendAnyOfSegment(result);
  }
  appendLiteralSegment(result, literals[literals.length - 1]);
  return result;
  function appendLiteralSegment(res, literalValue) {
    if (literalValue.length !== 0) {
      res.push({
        type: 'literal',
        value: literalValue
      });
    }
  }
  function appendAnyOfSegment(res) {
    res.push({
      type: 'anyOf',
      value: ' \t\n-'
    });
  }
}
class FilterValidator extends _baseValidator.AggregatingValidator {
  constructor(operatorName, previousInvalidArguments, ctor, constructorName) {
    super(previousInvalidArguments);
    this.operatorName = operatorName;
    this.ctor = ctor;
    this.constructorName = constructorName;
  }
  typeIsString(value) {
    return this.addValidation(() => (0, _typeUtils.isString)(value), () => _errors.messages.filterValidations.typeIsString(this.operatorName, value));
  }
  typeIsStringNumberOrDate(value) {
    return this.addValidation(() => isDateStringOrNumber(value), () => _errors.messages.filterValidations.typeIsStringNumberOrDate(this.operatorName, value));
  }
  sameType(first, second) {
    return this.addValidation(() => (0, _typeUtils.typeForDisplay)(first) === (0, _typeUtils.typeForDisplay)(second), () => _errors.messages.filterValidations.sameType(this.operatorName, first, second));
  }
  typeIsStringNumberOrDateForAll(values) {
    return this.addValidation(() => values.every(isDateStringOrNumber), () => _errors.messages.filterValidations.typeIsStringNumberOrDateForAll(this.operatorName));
  }
  validFieldName(field) {
    return this.addValidation(() => (0, _typeUtils.isString)(field), () => _errors.messages.filterValidations.validFieldName(this.operatorName, field));
  }
  isInstanceOfSameClass(obj) {
    return this.addValidation(() => obj instanceof this.ctor, () => _errors.messages.filterValidations.isInstanceOfSameClass(this.operatorName, this.constructorName, obj));
  }
  isForCollection(otherFilterBuilder, expectedCollectionName) {
    return this.addValidation(() => otherFilterBuilder.collectionName === expectedCollectionName, () => _errors.messages.filterValidations.isForCollection(this.operatorName, this.constructorName, otherFilterBuilder.collectionName));
  }
}
exports.FilterValidator = FilterValidator;
function isDateStringOrNumber(value) {
  return (0, _typeUtils.isString)(value) || (0, _typeUtils.isNumber)(value) || (0, _typeUtils.isDate)(value);
}
function withCollectionNameIfUnset(filter, name) {
  if (!filter || !filter.constructor) {
    return filter;
  }
  const collectionName = filter.collectionName ? filter.collectionName : name;
  return new filter.constructor({
    ...filter,
    collectionName
  });
}
var _default = exports.default = filterMixin;
//# sourceMappingURL=filterMixin.js.map