{"version":3,"names":["_errors","require","_typeUtils","filterTreeValidations","errors","messages","validateFilterOrThrow","tree","failures","validateFilterTree","length","validationError","join","path","isObject","objectType","collectedErrors","key","Object","keys","value","at","isArray","push","arrayType","flatMap","x","arrayLength","startsWith","validateOperatorOrValue","isComparableValue","some","op","validateOperator","operator","comparisonOperatorType","isString","stringOperatorType","isBoolean","every","setOperatorItems","ignoreCase","matchesOperatorIgnoreCase","spec","validSpec","type","invalid","find","undefined","matchesOperatorSpecItems","regexNotAllowed","isDate","isNumber","$date","prefix","next"],"sources":["../../../src/filter/FilterTree.ts"],"sourcesContent":["import { messages, validationError } from '../errors/errors'\nimport {\n  isArray,\n  isObject,\n  isString,\n  isDate,\n  isNumber,\n  isBoolean,\n} from '../utils/type-utils'\n\nexport type FilterTree =\n  | FieldFilter\n  | { $and?: FilterTree[] }\n  | { $or?: FilterTree[] }\n  | { $not?: FilterTree | [FilterTree] } // [FilterTree] is old format\n\nexport type FieldFilter = {\n  // just value is equivalent $eq operator\n  [field: string]: Operator | Value\n}\n\ntype DateValue = Date | { $date: string }\n\ntype ComparableValue = string | number | DateValue\n\ntype Value = any\n\nexport type Operator =\n  | { $eq?: Value }\n  | { $ne?: Value }\n  | { $gt?: ComparableValue }\n  | { $gte?: ComparableValue }\n  | { $lt?: ComparableValue }\n  | { $lte?: ComparableValue }\n  | { $startsWith?: string }\n  | { $endsWith?: string }\n  | { $contains?: string }\n  | { $exists?: boolean }\n  | { $hasSome?: ComparableValue[] }\n  | { $in?: ComparableValue[] }\n  | { $hasAll?: ComparableValue[] }\n  | {\n      $matches?: {\n        specs: {\n          type: 'literal' | 'anyOf'\n          value: string\n        }[]\n        ignoreCase: true\n      }\n    }\n  | { $not?: Operator }\n\nconst { filterTreeValidations: errors } = messages\n\nexport function validateFilterOrThrow(tree: unknown): tree is FilterTree {\n  const failures = validateFilterTree(tree)\n  if (failures.length === 0) {\n    return true\n  }\n  throw validationError(`Invalid filter:${failures.join('\\n')}`)\n}\n\nexport function validateFilterTree(tree: unknown, path?: string): string[] {\n  if (!isObject(tree)) {\n    return [errors.objectType('Filter Model', tree)]\n  }\n  const collectedErrors = [] as string[]\n  for (const key of Object.keys(tree)) {\n    const value = tree[key]\n    const at = join(path, key)\n    switch (key) {\n      case '$and':\n      case '$or':\n        if (!isArray(value)) {\n          collectedErrors.push(errors.arrayType(at, value))\n        }\n        if (isArray(value)) {\n          collectedErrors.push(\n            ...value.flatMap((x) => validateFilterTree(x, at))\n          )\n        }\n        break\n      case '$not':\n        if (!isArray(value)) {\n          collectedErrors.push(...validateFilterTree(value, at))\n        }\n        if (isArray(value) && value.length !== 1) {\n          collectedErrors.push(errors.arrayLength(at, 1, value))\n        }\n        if (isArray(value) && value.length > 0) {\n          collectedErrors.push(...validateFilterTree(value[0], at))\n        }\n        break\n      default:\n        if (key.startsWith('$')) {\n          collectedErrors.push(`Unexpected operator ${at}`)\n        } else {\n          collectedErrors.push(...validateOperatorOrValue(value, at))\n        }\n    }\n  }\n  return collectedErrors\n}\n\nfunction validateOperatorOrValue(value: unknown, path: string): string[] {\n  if (\n    isObject(value) &&\n    !isComparableValue(value) &&\n    Object.keys(value).some((op) => op.startsWith('$'))\n  ) {\n    return validateOperator(value, path)\n  }\n  return []\n}\n\nfunction validateOperator(operator: unknown, path: string): string[] {\n  if (!isObject(operator)) {\n    return [errors.objectType(path, operator)]\n  }\n  const collectedErrors = [] as string[]\n  for (const key of Object.keys(operator)) {\n    const at = join(path, key)\n    const value = operator[key]\n    switch (key) {\n      case '$eq':\n      case '$ne':\n        break\n      case '$gt':\n      case '$gte':\n      case '$lt':\n      case '$lte':\n        if (!isComparableValue(value)) {\n          collectedErrors.push(errors.comparisonOperatorType(at, value))\n        }\n        break\n      case '$startsWith':\n      case '$endsWith':\n      case '$contains':\n        if (!isString(value)) {\n          collectedErrors.push(errors.stringOperatorType(at, value))\n        }\n        break\n      case '$exists':\n        if (!isBoolean(value)) {\n          collectedErrors.push(`${at} should be a Boolean`)\n        }\n        break\n      case '$hasSome':\n      case '$hasAll':\n      case '$in':\n        if (!isArray(value)) {\n          collectedErrors.push(errors.arrayType(at, value))\n        }\n        if (isArray(value) && !value.every(isComparableValue)) {\n          collectedErrors.push(errors.setOperatorItems(at, value))\n        }\n        break\n      case '$matches':\n        if (!isObject(value)) {\n          collectedErrors.push(errors.objectType(at, value))\n        }\n        if (isObject(value) && value.ignoreCase !== true) {\n          collectedErrors.push(errors.matchesOperatorIgnoreCase(value))\n        }\n        if (isObject(value) && !isArray(value.spec)) {\n          collectedErrors.push(errors.arrayType(`${at}.spec`, value.spec))\n        }\n        if (isArray(value?.spec)) {\n          const validSpec = (spec: any) => {\n            if (!isObject(spec)) {\n              return false\n            }\n            if (spec.type === 'anyOf' && spec.value === ' \\t\\n-') {\n              return true\n            }\n            return spec.type === 'literal' && isString(spec.value)\n          }\n          const invalid = value.spec.find((x: any) => !validSpec(x))\n          if (invalid !== undefined) {\n            collectedErrors.push(errors.matchesOperatorSpecItems(invalid))\n          }\n        }\n        break\n      case '$regex':\n        collectedErrors.push(errors.regexNotAllowed())\n        break\n      case '$not':\n        collectedErrors.push(...validateOperator(value, at))\n        break\n      default:\n        collectedErrors.push(`Unknown operator ${at}`)\n    }\n  }\n  return collectedErrors\n}\n\nfunction isComparableValue(x: unknown): x is ComparableValue {\n  if (isDate(x) || isString(x) || isNumber(x)) {\n    return true\n  }\n  return isObject(x) && isString(x.$date) && Object.keys(x).length === 1\n}\n\nfunction join(prefix: string | undefined, next: string) {\n  return prefix === undefined ? next : `${prefix}.${next}`\n}\n"],"mappings":"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","ignoreList":[]}