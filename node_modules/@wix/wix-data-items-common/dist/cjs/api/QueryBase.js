"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.QueryBase = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _filter = require("../filter");
var _sortMixin = require("../sort/sortMixin");
var _common = require("./common");
class QueryBase {
  constructor(origin) {
    /**
     * @internal
     */
    (0, _defineProperty2.default)(this, "filterBuilder", void 0);
    /**
     * @internal
     */
    (0, _defineProperty2.default)(this, "sort", void 0);
    /**
     * @internal
     */
    (0, _defineProperty2.default)(this, "collectionName", void 0);
    // filterMethod: WithFilter<Self>['filterMethod'] allows keeping type signature while capturing
    // all args as an array
    (0, _defineProperty2.default)(this, "eq", (...args) => {
      return this.withFilter('eq', args);
    });
    (0, _defineProperty2.default)(this, "ne", (...args) => {
      return this.withFilter('ne', args);
    });
    (0, _defineProperty2.default)(this, "ge", (...args) => {
      return this.withFilter('ge', args);
    });
    (0, _defineProperty2.default)(this, "gt", (...args) => {
      return this.withFilter('gt', args);
    });
    (0, _defineProperty2.default)(this, "gte", (...args) => {
      return this.withFilter('gte', args);
    });
    (0, _defineProperty2.default)(this, "le", (...args) => {
      return this.withFilter('le', args);
    });
    (0, _defineProperty2.default)(this, "lt", (...args) => {
      return this.withFilter('lt', args);
    });
    (0, _defineProperty2.default)(this, "lte", (...args) => {
      return this.withFilter('lte', args);
    });
    (0, _defineProperty2.default)(this, "isNotEmpty", (...args) => {
      return this.withFilter('isNotEmpty', args);
    });
    (0, _defineProperty2.default)(this, "isEmpty", (...args) => {
      return this.withFilter('isEmpty', args);
    });
    (0, _defineProperty2.default)(this, "startsWith", (...args) => {
      return this.withFilter('startsWith', args);
    });
    (0, _defineProperty2.default)(this, "endsWith", (...args) => {
      return this.withFilter('endsWith', args);
    });
    (0, _defineProperty2.default)(this, "contains", (...args) => {
      return this.withFilter('contains', args);
    });
    (0, _defineProperty2.default)(this, "hasSome", (...args) => {
      return this.withFilter('hasSome', args);
    });
    (0, _defineProperty2.default)(this, "in", (...args) => {
      return this.withFilter('in', args);
    });
    (0, _defineProperty2.default)(this, "hasAll", (...args) => {
      return this.withFilter('hasAll', args);
    });
    (0, _defineProperty2.default)(this, "exists", (...args) => {
      return this.withFilter('exists', args);
    });
    (0, _defineProperty2.default)(this, "or", (...args) => {
      // @ts-expect-error
      return this.withFilter('or', args.map(this.extractFilter));
    });
    (0, _defineProperty2.default)(this, "and", (...args) => {
      // @ts-expect-error
      return this.withFilter('and', args.map(this.extractFilter));
    });
    (0, _defineProperty2.default)(this, "not", (...args) => {
      // @ts-expect-error
      return this.withFilter('not', args.map(this.extractFilter));
    });
    (0, _defineProperty2.default)(this, "between", (...args) => {
      return this.withFilter('between', args);
    });
    this.collectionName = origin.collectionName;
    this.filterBuilder = (origin == null ? void 0 : origin.filterBuilder) ?? (0, _common.filterBuilder)({
      filterTree: {}
    });
    this.sort = (origin == null ? void 0 : origin.sort) ?? new _sortMixin.Sort();
  }

  /**
   * @internal
   */

  // --- filter ---

  get filterTree() {
    return this.filterBuilder.filterTree;
  }

  /**
   * @internal
   */
  setFilterModel(filterTree) {
    const filter = (0, _common.filterBuilder)({
      filterTree,
      invalidArguments: (0, _filter.validateFilterTree)(filterTree)
    });
    return this.copy({
      filterBuilder: filter
    });
  }

  /**
   * @internal
   */
  getFilterModel() {
    return this.filterBuilder.build();
  }
  withFilter(filter, args) {
    return this.copy({
      filterBuilder: this.filterBuilder[filter].apply(this.filterBuilder, args)
    });
  }
  extractFilter(value) {
    return value != null && value.filterBuilder ? value.filterBuilder : value;
  }

  // --- sort ---

  get orderBy() {
    return this.sort.orderBy;
  }

  /**
   * Adds a sort to a query or sort, sorting by the specified properties in ascending order.
   *
   * The `ascending()` function refines this query in ascending order of the specified properties. If you specify more
   * than one property, `ascending()` sorts the results in ascending order by each property in the order they are listed.
   *
   * You can sort the following types:
   * - Number: Sorts numerically.
   * - Date: Sorts by date and time.
   * - String: Sorts lexicographically, so `"abc"` comes after `"XYZ"`.
   * - Reference: Compares by the ID of the referenced item as a String.
   *
   * If a property contains a number as a String, that value will be sorted alphabetically and not numerically.
   * Items that do not have a value for the specified sort property are ranked lowest.
   * @public
   * @documentationMaturity preview
   * @param fields - The properties used in the sort.
   * @requiredField fields
   * @returns An object representing the refined query.
   */

  ascending(...fields) {
    return this.copy({
      sort: this.sort.ascending(...fields)
    });
  }

  /**
   * Adds a sort to a query or sort, sorting by the specified properties in descending order.
   *
   * The `descending()` function refines this query to sort in descending order of the specified properties. If you
   * specify more than one property, descending() sorts the results in descending order by each property in the order
   * they are listed.
   *
   * You can sort the following types:
   *
   * Number: Sorts numerically.
   * - Date: Sorts by date and time.
   * - String: Sorts lexicographically, so `"abc"` comes before `"XYZ"`.
   * - Reference: Compares by the ID of the referenced item as a String.
   *
   * If a property contains a number as a String, that value will be sorted alphabetically and not numerically. Items
   * that do not have a value for the specified sort property are ranked lowest.
   * @public
   * @documentationMaturity preview
   * @param fields - The properties used in the sort.
   * @requiredField fields
   * @returns An object representing the refined query.
   */

  descending(...fields) {
    return this.copy({
      sort: this.sort.descending(...fields)
    });
  }
}
exports.QueryBase = QueryBase;
//# sourceMappingURL=QueryBase.js.map