"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.WixDataApi = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _errors = require("../errors");
var apiTypes = _interopRequireWildcard(require("../types/data-item-types"));
var _utils = require("../utils");
var _common = require("./common");
var _WixDataQueryImpl = require("./impl/WixDataQueryImpl");
var _WixDataResultImpl = require("./impl/WixDataResultImpl");
var _WixDataAggregateImpl = require("./impl/WixDataAggregateImpl");
var _ApiClient = require("./ApiClient");
var _WixDataPatchImpl = require("./impl/WixDataPatchImpl");
var _WixDataSearchImpl = require("./impl/WixDataSearchImpl");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class WixDataApi {
  constructor(clientFactory, allowGet, environment, gridAppId, tracer) {
    this.environment = environment;
    this.gridAppId = gridAppId;
    this.tracer = tracer;
    (0, _defineProperty2.default)(this, "client", void 0);
    // NOTE sort method for builder is not implemented
    (0, _defineProperty2.default)(this, "truncate", withArgs(async (args, collectionName, options) => {
      await apiValidator().arity('truncate', args, 1, 2).collectionName(collectionName).options(options).validateAndReject();
      return this.trace('truncate', {
        collectionName
      })(async env => {
        await this.client.truncateDataItems({
          ...env,
          dataCollectionId: collectionName,
          ...toOptions(options)
        });
      });
    }));
    // --- single-item methods ---
    (0, _defineProperty2.default)(this, "get", withArgs(async (args, collectionName, itemId, options) => {
      await apiValidator().arity('get', args, 2, 3).collectionName(collectionName).itemId(itemId).options(options).validateAndReject();
      return this.trace('get', {
        collectionName,
        itemId
      })(async env => {
        const {
          dataItem
        } = await this.client.getDataItem({
          ...env,
          dataCollectionId: collectionName,
          dataItemId: itemId,
          ...toReadOptions(options),
          fields: options == null ? void 0 : options.fields
        }).catch(recover(ItemDoesNotExistCode, {}));
        return dataItem ? toDataItem(dataItem) : null;
      });
    }));
    (0, _defineProperty2.default)(this, "insert", withArgs(async (args, collectionName, item, options) => {
      await apiValidator().arity('insert', args, 2, 3).collectionName(collectionName).item(item, collectionName, false).options(options).validateAndReject();
      warnAboutBrokenFields(item);
      return this.trace('insert', {
        collectionName
      })(async env => {
        const {
          dataItem
        } = await this.client.insertDataItem({
          ...env,
          dataCollectionId: collectionName,
          dataItem: {
            id: item._id,
            data: item
          },
          ...toUpdateOptions(options)
        });
        return toDataItem(dataItem);
      });
    }));
    (0, _defineProperty2.default)(this, "save", withArgs(async (args, collectionName, item, options) => {
      await apiValidator().arity('save', args, 2, 3).collectionName(collectionName).item(item, collectionName, false).options(options).validateAndReject();
      return this.trace('save', {
        collectionName
      })(async env => {
        const {
          dataItem
        } = await this.client.saveDataItem({
          ...env,
          dataCollectionId: collectionName,
          dataItem: {
            id: item._id,
            data: item
          },
          ...toUpdateOptions(options)
        });
        return toDataItem(dataItem);
      });
    }));
    (0, _defineProperty2.default)(this, "update", withArgs(async (args, collectionName, item, options) => {
      await apiValidator().arity('update', args, 2, 3).collectionName(collectionName).item(item, collectionName, false).options(options).validateAndReject();
      return this.trace('update', {
        collectionName
      })(async env => {
        const {
          dataItem
        } = await this.client.updateDataItem({
          ...env,
          dataCollectionId: collectionName,
          dataItem: {
            id: item._id,
            data: item
          },
          ...toUpdateOptions(options)
        });
        return toDataItem(dataItem);
      });
    }));
    (0, _defineProperty2.default)(this, "remove", withArgs(async (args, collectionName, itemId, options) => {
      await apiValidator().arity('remove', args, 2, 3).collectionName(collectionName).itemId(itemId).options(options).validateAndReject();
      return this.trace('remove', {
        collectionName,
        itemId
      })(async env => {
        const {
          dataItem
        } = await this.client.removeDataItem({
          ...env,
          dataCollectionId: collectionName,
          dataItemId: itemId,
          ...toOptions(options)
        }).catch(recover(ItemDoesNotExistCode, {}));
        return dataItem ? toDataItem(dataItem) : null;
      });
    }));
    (0, _defineProperty2.default)(this, "toFieldModificationApi", fieldModification => {
      switch (fieldModification.action) {
        case 'SET_FIELD':
          return {
            action: apiTypes.ACTION.SET_FIELD,
            fieldPath: fieldModification.fieldPath,
            setFieldOptions: {
              value: fieldModification.actionOptions
            }
          };
        case 'REMOVE_FIELD':
          return {
            action: apiTypes.ACTION.REMOVE_FIELD,
            fieldPath: fieldModification.fieldPath
          };
        case 'INCREMENT_FIELD':
          return {
            action: apiTypes.ACTION.INCREMENT_FIELD,
            fieldPath: fieldModification.fieldPath,
            incrementFieldOptions: {
              value: fieldModification.actionOptions
            }
          };
        case 'APPEND_TO_ARRAY':
          return {
            action: apiTypes.ACTION.APPEND_TO_ARRAY,
            fieldPath: fieldModification.fieldPath,
            appendToArrayOptions: {
              value: fieldModification.actionOptions
            }
          };
        case 'REMOVE_FROM_ARRAY':
          return {
            action: apiTypes.ACTION.REMOVE_FROM_ARRAY,
            fieldPath: fieldModification.fieldPath,
            removeFromArrayOptions: {
              value: fieldModification.actionOptions
            }
          };
        default:
          throw new Error('Invalid patch action');
      }
    });
    (0, _defineProperty2.default)(this, "patch", (collectionName, itemId) => {
      return new _WixDataPatchImpl.WixDataPatchImpl({
        collectionName,
        itemId,
        onRun: async (_args, patchParams, options) => {
          const fieldModifications = patchParams.fieldModifications.map(this.toFieldModificationApi);
          return this.trace('patch', {
            collectionName
          })(async env => {
            const result = await this.client.patchDataItem({
              ...env,
              dataCollectionId: patchParams.collectionName,
              patch: {
                dataItemId: patchParams.itemId,
                fieldModifications
              },
              ...toPatchOptions(options)
            });
            return result.dataItem ? toDataItem(result.dataItem) : null;
          });
        }
      });
    });
    (0, _defineProperty2.default)(this, "bulkPatch", (collectionName, itemIds) => {
      return new _WixDataPatchImpl.WixDataBulkPatchImpl({
        collectionName,
        itemIds,
        onRun: async (_args, patchParams, options) => {
          const fieldModifications = patchParams.fieldModifications.map(this.toFieldModificationApi);
          return this.trace('bulkPatch', {
            collectionName
          })(async env => {
            const {
              results
            } = await this.client.bulkPatchDataItems({
              ...env,
              dataCollectionId: patchParams.collectionName,
              patches: patchParams.itemIds.map(itemId => ({
                dataItemId: itemId,
                fieldModifications
              })),
              ...toPatchOptions(options)
            });
            return toBulkResult(itemIds, results, ['WDE0073']);
          });
        }
      });
    });
    // --- query, count, distinct ---
    (0, _defineProperty2.default)(this, "query", collectionName => {
      const ensureValidQuery = invalidArgs => {
        if (invalidArgs.length > 0) {
          throw (0, _errors.wdeValidationError)(_errors.messages.queryValidations.queryInvalid(collectionName, invalidArgs));
        }
      };
      return new _WixDataQueryImpl.WixDataQueryImpl({
        collectionName,
        onCount: async (args, params, options) => {
          ensureValidQuery([...params.invalidArguments, ...apiValidator().collectionName(collectionName).arity('count', args, 0, 1).options(options).validateAndReturn()]);
          return this.trace('count', {
            collectionName
          })(async env => {
            const {
              totalCount
            } = await this.client.countDataItems({
              ...env,
              dataCollectionId: collectionName,
              filter: params.filterTree,
              ...toReadOptions(options)
            });
            return totalCount;
          });
        },
        onDistinct: async (args, params, field, options) => {
          var _toSort$find;
          ensureValidQuery([...params.invalidArguments, ...apiValidator().collectionName(collectionName).arity('distinct', args, 1, 2).fieldName(field).options(options).validateAndReturn()]);
          const order = (_toSort$find = toSort(params.orderBy).find(o => o.fieldName === field)) == null ? void 0 : _toSort$find.order;
          const fetch = (cursorOrOffset, returnTotalCount) => this.trace('distinct', {
            collectionName,
            field
          })(async env => {
            const {
              distinctValues,
              pagingMetadata
            } = await this.client.queryDistinctValues({
              ...env,
              dataCollectionId: collectionName,
              ...toReadOptions(options),
              ...toPaging(params.limitNumber, cursorOrOffset),
              ...(isOffset(cursorOrOffset) ? {
                fieldName: field,
                filter: params.filterTree,
                order,
                returnTotalCount
              } : {})
            });
            return [distinctValues, pagingMetadata];
          });
          const [items, paging] = await fetch(params.skipNumber, options == null ? void 0 : options.returnTotalCount);
          return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, params);
        },
        onFind: async (args, params, options) => {
          ensureValidQuery([...params.invalidArguments, ...apiValidator().collectionName(collectionName).arity('find', args, 0, 1).options(options).validateAndReturn()]);
          const fetch = (cursorOrOffset, returnTotalCount) => this.trace('query', {
            collectionName
          })(async env => {
            const {
              dataItems,
              pagingMetadata
            } = await this.client.queryDataItems({
              ...env,
              dataCollectionId: collectionName,
              query: {
                fields: params.projectedFields,
                ...toPaging(params.limitNumber, cursorOrOffset),
                ...(isOffset(cursorOrOffset) ? {
                  filter: params.filterTree,
                  sort: toSort(params.orderBy)
                } : {})
              },
              referencedItemOptions: params.included,
              ...toReadOptions(options),
              ...(isOffset(cursorOrOffset) ? {
                returnTotalCount
              } : {})
            });
            return [dataItems.map(toDataItem), pagingMetadata];
          });
          const [items, paging] = await fetch(params.skipNumber, options == null ? void 0 : options.returnTotalCount);
          return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, params);
        }
      });
    });
    (0, _defineProperty2.default)(this, "search", collectionName => {
      const ensureValidQuery = invalidArgs => {
        if (invalidArgs.length > 0) {
          throw (0, _errors.wdeValidationError)(_errors.messages.queryValidations.queryInvalid(collectionName, invalidArgs));
        }
      };
      return new _WixDataSearchImpl.WixDataSearchImpl({
        collectionName,
        onRun: async (params, options) => {
          ensureValidQuery([...params.invalidArguments, ...apiValidator().collectionName(collectionName).options(options).validateAndReturn()]);
          const expression = params.queryText;
          const fetch = cursorOrOffset => this.trace('search', {
            collectionName,
            expression
          })(async env => {
            const request = {
              ...env,
              dataCollectionId: collectionName,
              search: {
                filter: params.filterTree,
                sort: toSort(params.orderBy),
                fields: params.projectedFields,
                search: {
                  expression: params.queryText,
                  fuzzy: params.isFuzzy,
                  mode: params.searchMode
                },
                ...toPaging(params.limitNumber, cursorOrOffset)
              },
              referencedItemOptions: params.included,
              ...toReadOptions(options)
            };
            const {
              dataItems,
              pagingMetadata
            } = await this.client.searchDataItems(request);
            return [dataItems.map(toDataItem), pagingMetadata];
          });
          const [items, paging] = await fetch(params.skipNumber);
          return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, params);
        }
      });
    });
    // NOTE find method is not implemented
    (0, _defineProperty2.default)(this, "fetch", withArgs(async (args, collectionName, cursor, limit, options) => {
      await apiValidator().arity('fetch', args, 2, 4).collectionName(collectionName).isNonEmptyString(cursor, 'cursor').validateAndReject();
      const fetch = cursorOrOffset => this.trace('query', {
        collectionName
      })(async env => {
        const {
          dataItems,
          pagingMetadata
        } = await this.client.queryDataItems({
          ...env,
          dataCollectionId: collectionName,
          query: {
            ...toPaging(limit, cursorOrOffset)
          },
          ...toReadOptions(options)
        });
        return [dataItems.map(toDataItem), pagingMetadata];
      });
      const [items, paging] = await fetch(cursor);
      return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, {
        limitNumber: limit,
        collectionName,
        skipNumber: 0
      });
    }));
    // --- aggregate ---
    (0, _defineProperty2.default)(this, "aggregate", collectionName => {
      return new _WixDataAggregateImpl.WixDataAggregateImpl({
        collectionName,
        onRun: async (args, params, options) => {
          const validationErrors = [...params.invalidArguments, ...apiValidator().arity('run', args, 0, 1).collectionName(collectionName).options(options).validateAndReturn()];
          if (validationErrors.length > 0) {
            throw (0, _errors.wdeValidationError)(_errors.messages.aggregateValidations.aggregateInvalid(collectionName, validationErrors));
          }
          const fetch = (cursorOrOffset, returnTotalCount) => this.trace('aggregate', {
            collectionName
          })(async env => {
            const toOperation = field => field ? {
              itemFieldName: field
            } : undefined;
            const {
              results,
              pagingMetadata
            } = await this.client.aggregateDataItems({
              ...env,
              dataCollectionId: collectionName,
              ...toPaging(params.limitNumber, cursorOrOffset),
              ...toReadOptions(options),
              ...(isOffset(cursorOrOffset) ? {
                initialFilter: params.filterTree,
                aggregation: {
                  groupingFields: params.groupBy,
                  operations: params.aggregates.map(a => ({
                    resultFieldName: a.name,
                    average: toOperation(a.avg),
                    min: toOperation(a.min),
                    max: toOperation(a.max),
                    sum: toOperation(a.sum),
                    itemCount: a.count ? {} : undefined
                  }))
                },
                finalFilter: params.havingTree,
                sort: toSort(params.orderBy),
                returnTotalCount
              } : {})
            });
            return [unwrapAggregationId(results), pagingMetadata];
          });
          const [items, paging] = await fetch(params.skipNumber, options == null ? void 0 : options.returnTotalCount);
          return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, params);
        }
      });
    });
    (0, _defineProperty2.default)(this, "fetchAggregate", withArgs(async (args, collectionName, cursor, limit, options) => {
      await apiValidator().arity('fetchAggregate', args, 2, 4).collectionName(collectionName).isNonEmptyString(cursor, 'cursor').validateAndReject();
      const fetch = cursorOrOffset => this.trace('aggregate', {
        collectionName
      })(async env => {
        const {
          results,
          pagingMetadata
        } = await this.client.aggregateDataItems({
          ...env,
          dataCollectionId: collectionName,
          ...toPaging(limit, cursorOrOffset),
          ...toReadOptions(options)
        });
        return [unwrapAggregationId(results), pagingMetadata];
      });
      const [items, paging] = await fetch(cursor, true);
      return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, {
        limitNumber: limit,
        skipNumber: 0,
        collectionName
      });
    }));
    // --- bulk methods ---
    (0, _defineProperty2.default)(this, "bulkRemove", withArgs(async (args, collectionName, itemIds, options) => {
      await apiValidator().arity('bulkRemove', args, 2, 3).collectionName(collectionName).itemIds(itemIds, collectionName).bulkRemoveOptions(options).validateAndReject();
      return this.trace('bulkRemove', {
        collectionName
      })(async env => {
        const {
          results
        } = await this.client.bulkRemoveDataItems({
          ...env,
          dataCollectionId: collectionName,
          dataItemIds: itemIds,
          ...toOptions(options)
        });
        // Non-existing items are skipped and not reported as errors.
        return toBulkResult(itemIds, results, ['WDE0073']);
      });
    }));
    (0, _defineProperty2.default)(this, "bulkInsert", withArgs(async (args, collectionName, items, options) => {
      await apiValidator().arity('bulkInsert', args, 2, 3).items(items, collectionName).bulkInsertOptions(options).collectionName(collectionName).validateAndReject();
      return this.trace('bulkInsert', {
        collectionName,
        options
      })(async appId => this.runBulkSave(appId, collectionName, items, options, (options == null ? void 0 : options.overrideExisting) ?? false));
    }));
    (0, _defineProperty2.default)(this, "bulkSave", withArgs(async (args, collectionName, items, options) => {
      await apiValidator().arity('bulkSave', args, 2, 3).bulkInsertOptions(options).collectionName(collectionName).items(items, collectionName).validateAndReject();
      return this.trace('bulkSave', {
        collectionName
      })(async env => this.runBulkSave(env, collectionName, items, options));
    }));
    (0, _defineProperty2.default)(this, "bulkUpdate", withArgs(async (args, collectionName, items, options) => {
      await apiValidator().arity('bulkUpdate', args, 2, 3).bulkUpdateOptions(options).collectionName(collectionName).items(items, collectionName).validateAndReject();
      return this.trace('bulkUpdate', {
        collectionName
      })(async env => {
        const {
          results
        } = await this.client.bulkUpdateDataItems({
          ...env,
          dataCollectionId: collectionName,
          dataItems: items.map(data => ({
            id: data._id,
            data
          })),
          ...toOptions(options)
        });
        // Non-existing items are skipped and not reported as errors.
        return toBulkResult(items, results, ['WDE0073']);
      });
    }));
    // --- references ---
    (0, _defineProperty2.default)(this, "fetchReferenced", withArgs(async (args, collectionName, cursor, limit, options) => {
      await apiValidator().arity('fetchReferenced', args, 2, 4).isNonEmptyString(cursor, 'cursor').collectionName(collectionName).validateAndReject();
      const fetch = current => this.trace('fetchReferenced', {
        collectionName
      })(async env => {
        const {
          results,
          pagingMetadata
        } = await this.client.queryReferencedDataItems({
          ...env,
          ...toPaging(limit, current),
          ...toReadOptions(options),
          dataCollectionId: collectionName,
          fields: options == null ? void 0 : options.fields
        });
        return [onlyReferencedItems(results), pagingMetadata];
      });
      const [items, paging] = await fetch(cursor);
      return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, {
        collectionName,
        limitNumber: limit,
        skipNumber: 0
      });
    }));
    (0, _defineProperty2.default)(this, "queryReferenced", withArgs(async (args, collectionName, holdingItem, relationshipAttribute, options) => {
      await apiValidator().arity('queryReferenced', args, 3, 4).collectionName(collectionName).referenceParameter(holdingItem).isNonEmptyString(relationshipAttribute, 'relationshipAttribute').options(options).validateAndReject();
      const id = itemId(holdingItem);
      const fetch = (cursorOrOffset, returnTotalCount) => this.trace('queryReferenced', {
        collectionName,
        itemId: id,
        options,
        relationshipAttribute
      })(async env => {
        const {
          results,
          pagingMetadata
        } = await this.client.queryReferencedDataItems({
          ...env,
          ...toPaging((options == null ? void 0 : options.limit) ?? 50, cursorOrOffset),
          ...toReadOptions(options),
          dataCollectionId: collectionName,
          fields: options == null ? void 0 : options.fields,
          ...(isOffset(cursorOrOffset) ? {
            referringItemId: id,
            referringItemFieldName: relationshipAttribute,
            order: (options == null ? void 0 : options.order) === 'asc' ? apiTypes.SortOrder.ASC : (options == null ? void 0 : options.order) === 'desc' ? apiTypes.SortOrder.DESC : undefined,
            returnTotalCount
          } : {})
        });
        return [onlyReferencedItems(results), pagingMetadata];
      });
      const [items, paging] = await fetch((options == null ? void 0 : options.skip) ?? 0, options == null ? void 0 : options.returnTotalCount);
      return new _WixDataResultImpl.WixDataResultImpl(items, paging, fetch, {
        collectionName,
        limitNumber: (options == null ? void 0 : options.limit) ?? 50,
        skipNumber: (options == null ? void 0 : options.skip) ?? 0
      });
    }));
    (0, _defineProperty2.default)(this, "insertReference", withArgs(async (args, collectionName, refsOrAttr, leftOrOpts, right, options) => {
      let refs;
      let opts;
      let argc;
      if (typeof refsOrAttr === 'string') {
        const rights = asArray(right);
        refs = rights.map(r => ({
          relationshipName: refsOrAttr,
          left: leftOrOpts,
          right: r
        }));
        opts = options;
        argc = [4, 5];
      } else {
        refs = refsOrAttr;
        opts = leftOrOpts;
        argc = [2, 3];
      }
      await apiValidator().arity('insertReference', args, ...argc).collectionName(collectionName).references(refs).options(opts).validateAndReject();
      await this.trace('insertReference', {
        collectionName
      })(async env => this.client.bulkInsertDataItemReferences({
        ...env,
        dataCollectionId: collectionName,
        dataItemReferences: refs.map(r => ({
          referringItemFieldName: r.relationshipName,
          referringItemId: itemId(r.left),
          referencedItemId: itemId(r.right)
        })),
        ...toOptions(opts)
      }));
    }));
    (0, _defineProperty2.default)(this, "replaceReferences", withArgs(async (args, collectionName, relationshipAttribute, left, right, options) => {
      const rights = asArray(right);
      await apiValidator().arity('replaceReferences', args, 4, 5).collectionName(collectionName).isNonEmptyString(relationshipAttribute, 'relationshipAttribute').referenceParameter(left).referenceParameters(rights).options(options).validateAndReject();
      await this.trace('replaceReferences', {
        collectionName,
        relationshipAttribute
      })(async env => this.client.replaceDataItemReferences({
        ...env,
        dataCollectionId: collectionName,
        referringItemFieldName: relationshipAttribute,
        referringItemId: itemId(left),
        newReferencedItemIds: rights.map(itemId),
        ...toOptions(options)
      }));
    }));
    (0, _defineProperty2.default)(this, "removeReference", withArgs(async (args, collectionName, relationshipAttribute, left, right, options) => {
      const rights = asArray(right);
      await apiValidator().arity('removeReference', args, 4, 5).collectionName(collectionName).referenceParameter(left).referenceRemoveParameters(rights).isNonEmptyString(relationshipAttribute, 'relationshipAttribute').options(options).validateAndReject();
      await this.trace('removeReference', {
        collectionName,
        relationshipAttribute
      })(async env => this.client.bulkRemoveDataItemReferences({
        ...env,
        dataCollectionId: collectionName,
        dataItemReferences: rights.map(r => ({
          referringItemFieldName: relationshipAttribute,
          referringItemId: itemId(left),
          referencedItemId: itemId(r)
        })),
        ...toOptions(options)
      }));
    }));
    (0, _defineProperty2.default)(this, "isReferenced", withArgs(async (args, collectionName, relationshipAttribute, left, right, options) => {
      await apiValidator().arity('isReferenced', args, 4, 5).collectionName(collectionName).referenceParameter(left).referenceParameter(right).options(options).validateAndReject();
      return this.trace('isReferenced', {
        collectionName,
        relationshipAttribute
      })(async env => {
        const {
          isReferenced
        } = await this.client.isReferencedDataItem({
          ...env,
          dataCollectionId: collectionName,
          referringItemFieldName: relationshipAttribute,
          referringItemId: itemId(left),
          referencedItemId: itemId(right),
          ...toReadOptions(options),
          consistentRead: options == null ? void 0 : options.consistentRead
        });
        return isReferenced;
      });
    }));
    this.client = new _ApiClient.ApiClient(clientFactory, allowGet);
  }
  get wixData() {
    return this;
  }
  get filter() {
    return (0, _common.filterBuilder)();
  }
  async runBulkSave(env, collectionName, items, options, overrideExisting = true) {
    const request = {
      ...env,
      dataCollectionId: collectionName,
      dataItems: items.map(data => ({
        id: data._id,
        data
      })),
      ...toOptions(options)
    };
    const {
      results
    } = await (overrideExisting ? this.client.bulkSaveDataItems(request) : this.client.bulkInsertDataItems(request));
    const ignoreCodes = overrideExisting ? [] : ['WDE0074'];
    return toBulkResult(items, results, ignoreCodes);
  }
  trace(action, opts) {
    return async fn => {
      const gridAppId = await get(this.gridAppId);
      const env = {
        appId: gridAppId,
        environment: this.environment
      };
      if (this.tracer) {
        return this.tracer(`WixDataApi.${action}`, {
          ...opts,
          gridAppId,
          environment: this.environment
        })(() => fn(env));
      }
      return fn(env);
    };
  }
}
exports.WixDataApi = WixDataApi;
function withArgs(fn) {
  return function (...args) {
    return fn(arguments, ...args);
  };
}
function toPatchOptions(options) {
  return {
    suppressHooks: options == null ? void 0 : options.suppressHooks,
    ...draftsOptions(options == null ? void 0 : options.showDrafts)
  };
}
function toUpdateOptions(options) {
  return {
    ...toOptions(options),
    includeReferencedItems: options == null ? void 0 : options.includeReferences
  };
}
function toOptions(opts) {
  if (!opts) {
    return undefined;
  }
  const res = {
    suppressHooks: opts.suppressHooks,
    appOptions: opts.appOptions,
    ...draftsOptions(opts == null ? void 0 : opts.showDrafts)
  };
  if (Object.entries(res).every(kv => kv[1] === undefined)) {
    return undefined;
  }
  return res;
}
function toReadOptions(options) {
  return {
    suppressHooks: options == null ? void 0 : options.suppressHooks,
    appOptions: options == null ? void 0 : options.appOptions,
    ...draftsOptions(options == null ? void 0 : options.showDrafts),
    consistentRead: options == null ? void 0 : options.consistentRead,
    language: options == null ? void 0 : options.language
  };
}
function draftsOptions(showDrafts) {
  return showDrafts !== undefined ? {
    publishPluginOptions: {
      includeDraftItems: showDrafts
    }
  } : {};
}
function toDataItem(item) {
  return item.data;
}
function toPaging(limit, cursorOrOffset) {
  return typeof cursorOrOffset === 'string' ? {
    cursorPaging: {
      limit,
      cursor: cursorOrOffset
    }
  } : limit !== undefined || cursorOrOffset > 0 ? {
    paging: {
      limit,
      offset: cursorOrOffset
    }
  } : {};
}
function toSort(orderBy) {
  return orderBy.map(fieldOrder => {
    const [[fieldName, sort]] = Object.entries(fieldOrder);
    const order = sort === 'asc' ? apiTypes.SortOrder.ASC : sort === 'desc' ? apiTypes.SortOrder.DESC : undefined;
    return {
      fieldName,
      order
    };
  });
}
async function get(providerOrValue) {
  if (typeof (providerOrValue == null ? void 0 : providerOrValue.get) === 'function') {
    return providerOrValue.get();
  }
  return providerOrValue;
}
function recover(code, value) {
  return error => {
    var _details;
    if (error instanceof Error && (error == null || (_details = error.details) == null || (_details = _details.applicationError) == null ? void 0 : _details.code) === code) {
      return Promise.resolve(value);
    }
    return Promise.reject(error);
  };
}
function warnAboutBrokenFields(item) {
  const hasFieldWithDollar = (0, _utils.hasField)(item, key => key.startsWith('$'));
  const hasFieldWithDot = (0, _utils.hasField)(item, key => key.includes('.'));
  if (hasFieldWithDollar) {
    console.error("Data inserted contains field name prefixed with symbol '$'. It is not recommended to use such field names as it will not work with some data operations.");
  }
  if (hasFieldWithDot) {
    console.warn("Data inserted contains field name containing symbol '.'. It is not recommended to use such field names as it will not work with some data operations.");
  }
}
function toBulkResult(request, results, ignoreCodes = []) {
  const errors = results.flatMap(r => {
    var _r$itemMetadata, _r$itemMetadata2;
    if ((_r$itemMetadata = r.itemMetadata) != null && _r$itemMetadata.success || !((_r$itemMetadata2 = r.itemMetadata) != null && _r$itemMetadata2.error)) {
      return [];
    }
    if (ignoreCodes.includes(r.itemMetadata.error.code ?? '')) {
      return [];
    }
    return [new _errors.BulkError(r.itemMetadata.error.description, r.itemMetadata.error.code, request[r.itemMetadata.originalIndex], 'BulkError', r.itemMetadata.originalIndex)];
  });
  const success = results.filter(r => {
    var _r$itemMetadata3;
    return (_r$itemMetadata3 = r.itemMetadata) == null ? void 0 : _r$itemMetadata3.success;
  });
  const inserted = success.filter(r => r.action === apiTypes.BulkActionType.INSERT);
  const updated = success.filter(r => r.action === apiTypes.BulkActionType.UPDATE || r.action === apiTypes.BulkActionType.PATCH);
  const removed = success.filter(r => r.action === apiTypes.BulkActionType.DELETE);
  return {
    inserted: inserted.length,
    updated: updated.length,
    removed: removed.length,
    skipped: request.length - errors.length - success.length,
    errors,
    insertedItemIds: inserted.map(r => {
      var _r$itemMetadata4;
      return (_r$itemMetadata4 = r.itemMetadata) == null ? void 0 : _r$itemMetadata4.id;
    }),
    updatedItemIds: updated.map(r => {
      var _r$itemMetadata5;
      return (_r$itemMetadata5 = r.itemMetadata) == null ? void 0 : _r$itemMetadata5.id;
    }),
    removedItemIds: removed.map(r => {
      var _r$itemMetadata6;
      return (_r$itemMetadata6 = r.itemMetadata) == null ? void 0 : _r$itemMetadata6.id;
    })
  };
}
function unwrapAggregationId(items) {
  // When grouping by one field WixDataService returns value on _id field directly, DataItemService wraps it in an object, i.e.
  // grouping by surname returns {_id: 'Simpson'} in WixDataService vs {_id: {surname: 'Simpson'}} in DataItemService
  // When grouping by more fields, values are kept wrapped.
  return items.map(item => {
    const id = item._id;
    if ((0, _utils.isObject)(id)) {
      const [key, ...rest] = Object.keys(id);
      if (rest.length === 0) {
        item._id = id[key];
        return item;
      }
    }
    return item;
  });
}
function onlyReferencedItems(results) {
  return results.map(result => result.dataItem).filter(notEmpty).map(toDataItem);
}
function notEmpty(value) {
  return value != null;
}
function itemId(item) {
  return typeof item === 'string' ? item : item._id;
}
function asArray(xOrXs) {
  return (0, _utils.isArray)(xOrXs) ? xOrXs : [xOrXs];
}
function isOffset(cursorOrOffset) {
  return typeof cursorOrOffset === 'number';
}
const ItemDoesNotExistCode = 'WDE0073';
function apiValidator() {
  return (0, _errors.apiValidator)(_errors.wdeValidationError);
}
//# sourceMappingURL=WixDataApi.js.map