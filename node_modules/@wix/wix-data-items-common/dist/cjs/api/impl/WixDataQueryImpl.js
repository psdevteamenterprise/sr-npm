"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.WixDataQueryImpl = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _QueryValidator = require("../QueryValidator");
var _QueryBase = require("../QueryBase");
class WixDataQueryImpl extends _QueryBase.QueryBase {
  constructor(origin) {
    super(origin);
    (0, _defineProperty2.default)(this, "projectedFields", void 0);
    (0, _defineProperty2.default)(this, "limitNumber", void 0);
    (0, _defineProperty2.default)(this, "skipNumber", void 0);
    (0, _defineProperty2.default)(this, "included", void 0);
    (0, _defineProperty2.default)(this, "onFind", void 0);
    (0, _defineProperty2.default)(this, "onDistinct", void 0);
    (0, _defineProperty2.default)(this, "onCount", void 0);
    (0, _defineProperty2.default)(this, "ownInvalidArguments", void 0);
    this.projectedFields = (origin == null ? void 0 : origin.projectedFields) ?? [];
    this.limitNumber = origin == null ? void 0 : origin.limitNumber;
    this.skipNumber = (origin == null ? void 0 : origin.skipNumber) ?? 0;
    this.included = (origin == null ? void 0 : origin.included) ?? [];
    this.onFind = origin.onFind;
    this.onDistinct = origin.onDistinct;
    this.onCount = origin.onCount;
    this.ownInvalidArguments = origin.invalidArguments ?? [];
  }
  copy(params) {
    return new WixDataQueryImpl({
      ...this,
      filterBuilder: params.filterBuilder ?? this.filterBuilder,
      projectedFields: params.projectedFields ?? this.projectedFields,
      limitNumber: params.limitNumber ?? this.limitNumber,
      skipNumber: params.skipNumber ?? this.skipNumber,
      included: params.included ?? this.included,
      sort: params.sort ?? this.sort,
      invalidArguments: params.invalidArguments ?? this.ownInvalidArguments,
      onFind: this.onFind,
      onDistinct: this.onDistinct,
      onCount: this.onCount
    });
  }
  count(options) {
    return this.onCount(arguments, this.toQueryParams(), options);
  }
  distinct(field, options) {
    return this.onDistinct(arguments, this.toQueryParams(), field, options);
  }
  find(options) {
    return this.onFind(arguments, this.toQueryParams(), options);
  }
  get invalidArguments() {
    return [...this.ownInvalidArguments, ...this.filterBuilder.invalidArguments, ...this.sort.invalidArguments];
  }
  toQueryParams() {
    let filterTree;
    try {
      // optimized filter if no errors
      filterTree = this.filterBuilder.build();
    } catch (_error) {
      filterTree = this.filterBuilder.filterTree;
    }
    return {
      collectionName: this.collectionName,
      invalidArguments: this.invalidArguments,
      projectedFields: this.projectedFields,
      limitNumber: this.limitNumber,
      skipNumber: this.skipNumber,
      included: this.included,
      filterTree,
      orderBy: this.orderBy
    };
  }
  fields(...fields) {
    return this.copy({
      projectedFields: [...this.projectedFields, ...fields]
    });
  }
  limit(limitNumber) {
    const [invalidArguments] = this.queryValidator('.limit').arityIsOne(arguments).isPositiveNumber(limitNumber).isInteger(limitNumber).validateAndAggregate();
    return this.copy({
      invalidArguments,
      limitNumber
    });
  }
  skip(skipNumber) {
    const [invalidArguments] = this.queryValidator('.skip').arityIsOne(arguments).isNonNegativeNumber(skipNumber).isInteger(skipNumber).validateAndAggregate();
    return this.copy({
      invalidArguments,
      skipNumber
    });
  }
  include(...args) {
    if (args.length === 0) {
      return this;
    }
    const last = args[args.length - 1];
    const limit = typeof last === 'number' ? last : undefined;
    const expectedFieldNameCount = limit === undefined ? args.length : args.length - 1;
    const newIncludes = args.slice(0, expectedFieldNameCount).map(fieldName => ({
      fieldName: fieldName,
      limit
    }));
    const [invalidArguments] = args.slice(0, expectedFieldNameCount).reduce((validator, value, _, __) => validator.nonEmptyString(value), this.queryValidator('.include')).validateAndAggregate();
    return this.copy({
      invalidArguments,
      included: [...this.included, ...newIncludes]
    });
  }
  queryValidator(operatorName, invalidArguments = this.ownInvalidArguments) {
    return new _QueryValidator.QueryValidator(operatorName, invalidArguments);
  }
}
exports.WixDataQueryImpl = WixDataQueryImpl;
//# sourceMappingURL=WixDataQueryImpl.js.map