"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.WixDataAggregateImpl = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _filter = require("../../filter");
var _QueryBase = require("../QueryBase");
var _errors = require("../../errors");
var _utils = require("../../utils");
class WixDataAggregateImpl extends _QueryBase.QueryBase {
  constructor(origin) {
    super(origin);
    (0, _defineProperty2.default)(this, "limitNumber", void 0);
    (0, _defineProperty2.default)(this, "skipNumber", void 0);
    (0, _defineProperty2.default)(this, "aggregates", void 0);
    (0, _defineProperty2.default)(this, "groupBy", void 0);
    (0, _defineProperty2.default)(this, "havingBuilder", void 0);
    (0, _defineProperty2.default)(this, "onRun", void 0);
    (0, _defineProperty2.default)(this, "ownInvalidArguments", void 0);
    this.limitNumber = origin.limitNumber;
    this.skipNumber = origin.skipNumber ?? 0;
    this.aggregates = origin.aggregates ?? [];
    this.groupBy = origin.groupBy ?? [];
    this.havingBuilder = origin.havingBuilder;
    this.onRun = origin.onRun;
    this.ownInvalidArguments = origin.invalidArguments ?? [];
  }
  copy(params) {
    return new WixDataAggregateImpl({
      ...this,
      limitNumber: params.limitNumber ?? this.limitNumber,
      skipNumber: params.skipNumber ?? this.skipNumber,
      havingBuilder: params.havingBuilder ?? this.havingBuilder,
      filterBuilder: params.filterBuilder ?? this.filterBuilder,
      sort: params.sort ?? this.sort,
      invalidArguments: params.invalidArguments ?? this.ownInvalidArguments,
      groupBy: params.groupBy ?? this.groupBy,
      aggregates: [...this.aggregates, ...(params.addAggregates ?? [])],
      onRun: this.onRun
    });
  }
  get invalidArguments() {
    var _this$havingBuilder;
    return [...this.ownInvalidArguments, ...this.filterBuilder.invalidArguments, ...(((_this$havingBuilder = this.havingBuilder) == null ? void 0 : _this$havingBuilder.invalidArguments) ?? []), ...this.sort.invalidArguments];
  }
  run(options) {
    let filterTree;
    try {
      // optimized filter if no errors
      filterTree = this.filterBuilder.build();
    } catch (_error) {
      filterTree = this.filterBuilder.filterTree;
    }
    let havingTree;
    try {
      var _this$havingBuilder2;
      // optimized filter if no errors
      havingTree = (_this$havingBuilder2 = this.havingBuilder) == null ? void 0 : _this$havingBuilder2.build();
    } catch (_error) {
      var _this$havingBuilder3;
      havingTree = (_this$havingBuilder3 = this.havingBuilder) == null ? void 0 : _this$havingBuilder3.filterTree;
    }
    return this.onRun(arguments, {
      collectionName: this.collectionName,
      invalidArguments: this.invalidArguments,
      filterTree,
      havingTree,
      aggregates: this.aggregates,
      groupBy: this.groupBy,
      limitNumber: this.limitNumber,
      skipNumber: this.skipNumber,
      orderBy: this.orderBy
    }, options);
  }

  // --- accumulators ---

  addAggregate(args, type, fieldName, alias) {
    const [invalidArguments] = this.aggregateValidator(type).arityIsAtLeastOne(args).typeIsString(fieldName).typeIsStringIfSet(alias).validateAndAggregate();
    return this.copy({
      invalidArguments,
      addAggregates: [{
        name: alias ?? `${fieldName}${type[0].toUpperCase()}${type.substr(1)}`,
        [type]: fieldName
      }]
    });
  }
  sum(fieldName, projectedField) {
    return this.addAggregate(arguments, 'sum', fieldName, projectedField);
  }
  avg(fieldName, projectedField) {
    return this.addAggregate(arguments, 'avg', fieldName, projectedField);
  }
  min(fieldName, projectedField) {
    return this.addAggregate(arguments, 'min', fieldName, projectedField);
  }
  max(fieldName, projectedField) {
    return this.addAggregate(arguments, 'max', fieldName, projectedField);
  }
  count(projectedField = 'count') {
    const [invalidArguments] = this.aggregateValidator('count').arityIsZero(arguments).typeIsString(projectedField).validateAndAggregate();
    return this.copy({
      invalidArguments,
      addAggregates: [{
        name: projectedField,
        count: true
      }]
    });
  }
  filter(filterBuilder) {
    const [invalidArguments] = this.aggregateValidator('.filter').arityIsOne(arguments).filterIsNotSet(this.filterBuilder).filterBuilder(filterBuilder).validateAndAggregate();
    return this.copy({
      filterBuilder,
      invalidArguments
    });
  }
  group(...fieldName) {
    const [invalidArguments] = this.aggregateValidator('.group').arityIsAtLeastOne(arguments).groupIsNotSet(this.groupBy).validateAndAggregate();
    return this.copy({
      groupBy: fieldName,
      invalidArguments
    });
  }
  having(filterBuilder) {
    const [invalidArguments] = this.aggregateValidator('.having').arityIsOne(arguments).havingIsNotSet(this.havingBuilder).filterBuilder(filterBuilder).validateAndAggregate();
    return this.copy({
      havingBuilder: filterBuilder,
      invalidArguments
    });
  }
  get havingTree() {
    var _this$havingBuilder4;
    return (_this$havingBuilder4 = this.havingBuilder) == null ? void 0 : _this$havingBuilder4.filterTree;
  }
  limit(limitNumber) {
    const [invalidArguments] = this.aggregateValidator('.limit').arityIsOne(arguments).isPositiveNumber(limitNumber).isInteger(limitNumber).validateAndAggregate();
    return this.copy({
      invalidArguments,
      limitNumber
    });
  }
  skip(skipNumber) {
    const [invalidArguments] = this.aggregateValidator('.skip').arityIsOne(arguments).isNonNegativeNumber(skipNumber).isInteger(skipNumber).validateAndAggregate();
    return this.copy({
      invalidArguments,
      skipNumber
    });
  }
  aggregateValidator(operatorName) {
    return new AggregationValidator(operatorName, this.ownInvalidArguments);
  }
}
exports.WixDataAggregateImpl = WixDataAggregateImpl;
const MAX_SAFE_INTEGER = 9007199254740991;
class AggregationValidator extends _errors.AggregatingValidator {
  constructor(operatorName, previousInvalidArguments) {
    super(previousInvalidArguments);
    this.operatorName = operatorName;
    this.operatorName = operatorName;
  }
  filterBuilder(filter) {
    return this.addValidation(() => filter instanceof _filter.PlatformizedFilterBuilder, () => _errors.messages.aggregateValidations.filterMustBeBuilder(this.operatorName));
  }
  filterIsNotSet(filter) {
    return this.addValidation(() => filter === undefined || !filter.hasAnyFilter(), () => _errors.messages.aggregateValidations.filterIsAlreadySet(this.operatorName));
  }
  havingIsNotSet(filter) {
    return this.addValidation(() => filter === undefined || !filter.hasAnyFilter(), () => _errors.messages.aggregateValidations.filterIsAlreadySet(this.operatorName));
  }
  groupIsNotSet(groupBy) {
    return this.addValidation(() => groupBy.length === 0, () => _errors.messages.aggregateValidations.groupIsAlreadySet(this.operatorName));
  }
  _isNumber(specifier, operand) {
    return this.addValidation(() => (0, _utils.isNumber)(operand), () => _errors.messages.queryValidations.isNumber(this.operatorName, specifier, operand));
  }
  isPositiveNumber(operand) {
    return this._isNumber('positive', operand).addValidation(() => !Number.isNaN(operand) && operand > 0, () => _errors.messages.queryValidations.isPositiveNumber(this.operatorName, operand));
  }
  isNonNegativeNumber(operand) {
    return this._isNumber('non-negative', operand).addValidation(() => !Number.isNaN(operand) && operand >= 0, () => _errors.messages.queryValidations.isNonNegativeNumber(this.operatorName, operand));
  }
  isInteger(operand) {
    return this.addValidation(() => !Number.isNaN(operand) && Number.isFinite(operand) && Number.isInteger(operand) && operand < MAX_SAFE_INTEGER && operand > -MAX_SAFE_INTEGER, () => _errors.messages.queryValidations.isInteger(this.operatorName, operand));
  }
  typeIsString(value) {
    return this.addValidation(() => (0, _utils.isString)(value), () => _errors.messages.filterValidations.typeIsString(this.operatorName, value));
  }
  typeIsStringIfSet(value) {
    return this.addValidation(() => value === undefined || (0, _utils.isString)(value), () => _errors.messages.filterValidations.typeIsString(this.operatorName, value));
  }
}
//# sourceMappingURL=WixDataAggregateImpl.js.map