"use strict";

exports.__esModule = true;
exports.isHttpError = isHttpError;
exports.parseError = parseError;
exports.parseHookError = parseHookError;
exports.parseValidationError = parseValidationError;
var _errors = require("../errors");
function isHttpError(error) {
  var _response;
  return !!((_response = error.response) != null && _response.status);
}
function parseHookError(error) {
  const data = error.details.applicationError.data;
  const errorData = (data == null ? void 0 : data.jsErrorValue) || !(data != null && data.value) && error.details.applicationError; // fallback to use default hook error message data
  if (errorData) {
    const {
      name,
      message,
      code,
      description
    } = errorData;
    const result = new Error(message || description);
    result.name = name || description;
    // @ts-expect-error
    result.code = code;
    return result;
  }
  return data == null ? void 0 : data.value;
}
function parseValidationError(error) {
  var _error$details;
  const fieldViolations = ((_error$details = error.details) == null || (_error$details = _error$details.validationError) == null ? void 0 : _error$details.fieldViolations) ?? [];
  const violations = fieldViolations.map(v => `${v.field}: ${v.description}`);
  return (0, _errors.wixDataError)([error.message, ...violations].join('\n'), undefined, error.details);
}
function parseError(error) {
  var _details$applicationE, _error$details2;
  const details = error.details ?? {};
  if (((_details$applicationE = details.applicationError) == null ? void 0 : _details$applicationE.code) === 'WDE0078') {
    const hookError = parseHookError(error);
    if (hookError) {
      return hookError;
    }
  }
  if (details.applicationError) {
    return (0, _errors.wixDataError)(details.applicationError.description, undefined, details);
  }
  if ((_error$details2 = error.details) != null && _error$details2.validationError) {
    return parseValidationError(error);
  }
  return null;
}
//# sourceMappingURL=errors.js.map