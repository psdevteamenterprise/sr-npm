"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = exports.SortValidator = exports.Sort = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _utils = require("../utils");
var _errors = require("../errors");
const sortMixin = (Base = class {}) => class extends Base {
  constructor(obj = {}) {
    super(obj);
    (0, _defineProperty2.default)(this, "orderBy", void 0);
    (0, _defineProperty2.default)(this, "invalidArguments", void 0);
    this.orderBy = obj.orderBy || [];
    this.invalidArguments = obj.invalidArguments || [];
  }
  ascending(...fields) {
    return this._sortClause('asc', '.ascending', fields);
  }
  descending(...fields) {
    return this._sortClause('desc', '.descending', fields);
  }
  getSortModel() {
    if (this.invalidArguments.length > 0) {
      throw (0, _errors.validationError)(_errors.messages.sortBuilderInvalid(this.invalidArguments));
    }
    return this.orderBy;
  }
  setSortModel(sortModel) {
    return this._copySort(sortModel, []);
  }
  _sortClause(operatorSymbol, operatorName, args) {
    let orderBy = [];
    if (this.orderBy) {
      orderBy = (0, _utils.clone)(this.orderBy);
    }
    const appendClause = createAppendClauseFn(orderBy, operatorSymbol);
    const effectiveArgs = (0, _utils.isArray)(args[0]) && args.length === 1 ? args[0] : Array.prototype.slice.call(args, 0);
    const [newInvalidArguments, valid] = this._sortValidator(operatorName).arityIsAtLeastOne(args).allStrings(effectiveArgs).validateAndAggregate();
    if (valid) {
      effectiveArgs.forEach(appendClause);
    }
    return this._copySort(orderBy, newInvalidArguments);
  }
  _sortValidator(operatorName) {
    return new SortValidator(operatorName, this.invalidArguments);
  }
  _copySort(orderBy, invalidArguments) {
    return new this.constructor({
      ...this,
      orderBy,
      invalidArguments
    });
  }
};
function createAppendClauseFn(destination, direction) {
  return field => {
    const spec = {
      [field]: direction
    };
    destination.push(spec);
  };
}
class SortValidator extends _errors.AggregatingValidator {
  constructor(operatorName, previousInvalidArguments) {
    super(previousInvalidArguments);
    this.operatorName = operatorName;
  }
  allStrings(effectiveArgs) {
    return this.addValidation(() => effectiveArgs.every(_utils.isString), () => {
      return _errors.messages.sortValidations.typeIsStringOrArrayOfStrings(this.operatorName, effectiveArgs);
    });
  }
}
exports.SortValidator = SortValidator;
class Sort extends sortMixin() {}
exports.Sort = Sort;
var _default = exports.default = sortMixin;
//# sourceMappingURL=sortMixin.js.map