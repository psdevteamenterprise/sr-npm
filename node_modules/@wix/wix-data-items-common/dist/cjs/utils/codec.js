"use strict";

exports.__esModule = true;
exports.decode = decode;
exports.encode = encode;
function encode(value) {
  return serializeDates(value);
}
function decode(value) {
  return parseDates(value);
}
function serializeDates(json) {
  if (typeof json !== 'object' || isDate(json)) {
    return json;
  }
  const obj = copyRoot(json);
  for (const k in obj) {
    const value = obj[k];
    if (value && isDate(value)) {
      obj[k] = stringifyDate(value);
    } else if (typeof obj[k] === 'object' && obj[k] !== null) {
      obj[k] = serializeDates(obj[k]);
    }
  }
  return obj;
}
function isDate(obj) {
  if (Object.prototype.toString.call(obj) !== '[object Date]') {
    return false;
  }
  return !isNaN(obj.getTime());
}
function isDateString(value) {
  return isNaN(value) && !isNaN(new Date(value).getDate());
}
function parseDates(json) {
  if (typeof json !== 'object' || isDate(json)) {
    return json;
  }
  const obj = copyRoot(json);
  for (const k in obj) {
    if (obj[k] && obj[k].$date && isDateString(obj[k].$date)) {
      obj[k] = new Date(obj[k].$date);
    } else if (typeof obj[k] === 'object' && obj[k] !== null) {
      obj[k] = parseDates(obj[k]);
    }
  }
  return obj;
}
function stringifyDate(d) {
  return {
    $date: d.toJSON()
  };
}
function copyRoot(obj) {
  if (Array.isArray(obj)) {
    return [...obj];
  } else {
    return {
      ...obj
    };
  }
}
//# sourceMappingURL=codec.js.map