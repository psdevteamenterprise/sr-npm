import { validateFilterTree, } from '../filter';
import { Sort } from '../sort/sortMixin';
import { filterBuilder } from './common';
export class QueryBase {
    constructor(origin) {
        // filterMethod: WithFilter<Self>['filterMethod'] allows keeping type signature while capturing
        // all args as an array
        this.eq = (...args) => {
            return this.withFilter('eq', args);
        };
        this.ne = (...args) => {
            return this.withFilter('ne', args);
        };
        this.ge = (...args) => {
            return this.withFilter('ge', args);
        };
        this.gt = (...args) => {
            return this.withFilter('gt', args);
        };
        this.gte = (...args) => {
            return this.withFilter('gte', args);
        };
        this.le = (...args) => {
            return this.withFilter('le', args);
        };
        this.lt = (...args) => {
            return this.withFilter('lt', args);
        };
        this.lte = (...args) => {
            return this.withFilter('lte', args);
        };
        this.isNotEmpty = (...args) => {
            return this.withFilter('isNotEmpty', args);
        };
        this.isEmpty = (...args) => {
            return this.withFilter('isEmpty', args);
        };
        this.startsWith = (...args) => {
            return this.withFilter('startsWith', args);
        };
        this.endsWith = (...args) => {
            return this.withFilter('endsWith', args);
        };
        this.contains = (...args) => {
            return this.withFilter('contains', args);
        };
        this.hasSome = (...args) => {
            return this.withFilter('hasSome', args);
        };
        this.in = (...args) => {
            return this.withFilter('in', args);
        };
        this.hasAll = (...args) => {
            return this.withFilter('hasAll', args);
        };
        this.exists = (...args) => {
            return this.withFilter('exists', args);
        };
        this.or = (...args) => {
            // @ts-expect-error
            return this.withFilter('or', args.map(this.extractFilter));
        };
        this.and = (...args) => {
            // @ts-expect-error
            return this.withFilter('and', args.map(this.extractFilter));
        };
        this.not = (...args) => {
            // @ts-expect-error
            return this.withFilter('not', args.map(this.extractFilter));
        };
        this.between = (...args) => {
            return this.withFilter('between', args);
        };
        this.collectionName = origin.collectionName;
        this.filterBuilder =
            origin?.filterBuilder ?? filterBuilder({ filterTree: {} });
        this.sort = origin?.sort ?? new Sort();
    }
    get filterTree() {
        return this.filterBuilder.filterTree;
    }
    /**
     * @internal
     */
    setFilterModel(filterTree) {
        const filter = filterBuilder({
            filterTree,
            invalidArguments: validateFilterTree(filterTree),
        });
        return this.copy({ filterBuilder: filter });
    }
    /**
     * @internal
     */
    getFilterModel() {
        return this.filterBuilder.build();
    }
    withFilter(filter, args) {
        return this.copy({
            filterBuilder: this.filterBuilder[filter].apply(this.filterBuilder, args),
        });
    }
    extractFilter(value) {
        return value?.filterBuilder ? value.filterBuilder : value;
    }
    // --- sort ---
    get orderBy() {
        return this.sort.orderBy;
    }
    ascending(...fields) {
        return this.copy({ sort: this.sort.ascending(...fields) });
    }
    descending(...fields) {
        return this.copy({ sort: this.sort.descending(...fields) });
    }
}
//# sourceMappingURL=QueryBase.js.map