import { PlatformizedFilterBuilder } from '../../filter';
import { QueryBase } from '../QueryBase';
import { AggregatingValidator, messages } from '../../errors';
import { isNumber, isString } from '../../utils';
export class WixDataAggregateImpl extends QueryBase {
    constructor(origin) {
        super(origin);
        this.limitNumber = origin.limitNumber;
        this.skipNumber = origin.skipNumber ?? 0;
        this.aggregates = origin.aggregates ?? [];
        this.groupBy = origin.groupBy ?? [];
        this.havingBuilder = origin.havingBuilder;
        this.onRun = origin.onRun;
        this.ownInvalidArguments = origin.invalidArguments ?? [];
    }
    copy(params) {
        return new WixDataAggregateImpl({
            ...this,
            limitNumber: params.limitNumber ?? this.limitNumber,
            skipNumber: params.skipNumber ?? this.skipNumber,
            havingBuilder: params.havingBuilder ?? this.havingBuilder,
            filterBuilder: params.filterBuilder ?? this.filterBuilder,
            sort: params.sort ?? this.sort,
            invalidArguments: params.invalidArguments ?? this.ownInvalidArguments,
            groupBy: params.groupBy ?? this.groupBy,
            aggregates: [...this.aggregates, ...(params.addAggregates ?? [])],
            onRun: this.onRun,
        });
    }
    get invalidArguments() {
        return [
            ...this.ownInvalidArguments,
            ...this.filterBuilder.invalidArguments,
            ...(this.havingBuilder?.invalidArguments ?? []),
            ...this.sort.invalidArguments,
        ];
    }
    run(options) {
        let filterTree;
        try {
            // optimized filter if no errors
            filterTree = this.filterBuilder.build();
        }
        catch (_error) {
            filterTree = this.filterBuilder.filterTree;
        }
        let havingTree;
        try {
            // optimized filter if no errors
            havingTree = this.havingBuilder?.build();
        }
        catch (_error) {
            havingTree = this.havingBuilder?.filterTree;
        }
        return this.onRun(arguments, {
            collectionName: this.collectionName,
            invalidArguments: this.invalidArguments,
            filterTree,
            havingTree,
            aggregates: this.aggregates,
            groupBy: this.groupBy,
            limitNumber: this.limitNumber,
            skipNumber: this.skipNumber,
            orderBy: this.orderBy,
        }, options);
    }
    // --- accumulators ---
    addAggregate(args, type, fieldName, alias) {
        const [invalidArguments] = this.aggregateValidator(type)
            .arityIsAtLeastOne(args)
            .typeIsString(fieldName)
            .typeIsStringIfSet(alias)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            addAggregates: [
                {
                    name: alias ?? `${fieldName}${type[0].toUpperCase()}${type.substr(1)}`,
                    [type]: fieldName,
                },
            ],
        });
    }
    sum(fieldName, projectedField) {
        return this.addAggregate(arguments, 'sum', fieldName, projectedField);
    }
    avg(fieldName, projectedField) {
        return this.addAggregate(arguments, 'avg', fieldName, projectedField);
    }
    min(fieldName, projectedField) {
        return this.addAggregate(arguments, 'min', fieldName, projectedField);
    }
    max(fieldName, projectedField) {
        return this.addAggregate(arguments, 'max', fieldName, projectedField);
    }
    count(projectedField = 'count') {
        const [invalidArguments] = this.aggregateValidator('count')
            .arityIsZero(arguments)
            .typeIsString(projectedField)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            addAggregates: [
                {
                    name: projectedField,
                    count: true,
                },
            ],
        });
    }
    filter(filterBuilder) {
        const [invalidArguments] = this.aggregateValidator('.filter')
            .arityIsOne(arguments)
            .filterIsNotSet(this.filterBuilder)
            .filterBuilder(filterBuilder)
            .validateAndAggregate();
        return this.copy({
            filterBuilder,
            invalidArguments,
        });
    }
    group(...fieldName) {
        const [invalidArguments] = this.aggregateValidator('.group')
            .arityIsAtLeastOne(arguments)
            .groupIsNotSet(this.groupBy)
            .validateAndAggregate();
        return this.copy({
            groupBy: fieldName,
            invalidArguments,
        });
    }
    having(filterBuilder) {
        const [invalidArguments] = this.aggregateValidator('.having')
            .arityIsOne(arguments)
            .havingIsNotSet(this.havingBuilder)
            .filterBuilder(filterBuilder)
            .validateAndAggregate();
        return this.copy({
            havingBuilder: filterBuilder,
            invalidArguments,
        });
    }
    get havingTree() {
        return this.havingBuilder?.filterTree;
    }
    limit(limitNumber) {
        const [invalidArguments] = this.aggregateValidator('.limit')
            .arityIsOne(arguments)
            .isPositiveNumber(limitNumber)
            .isInteger(limitNumber)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            limitNumber,
        });
    }
    skip(skipNumber) {
        const [invalidArguments] = this.aggregateValidator('.skip')
            .arityIsOne(arguments)
            .isNonNegativeNumber(skipNumber)
            .isInteger(skipNumber)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            skipNumber,
        });
    }
    aggregateValidator(operatorName) {
        return new AggregationValidator(operatorName, this.ownInvalidArguments);
    }
}
const MAX_SAFE_INTEGER = 9007199254740991;
class AggregationValidator extends AggregatingValidator {
    constructor(operatorName, previousInvalidArguments) {
        super(previousInvalidArguments);
        this.operatorName = operatorName;
        this.operatorName = operatorName;
    }
    filterBuilder(filter) {
        return this.addValidation(() => filter instanceof PlatformizedFilterBuilder, () => messages.aggregateValidations.filterMustBeBuilder(this.operatorName));
    }
    filterIsNotSet(filter) {
        return this.addValidation(() => filter === undefined || !filter.hasAnyFilter(), () => messages.aggregateValidations.filterIsAlreadySet(this.operatorName));
    }
    havingIsNotSet(filter) {
        return this.addValidation(() => filter === undefined || !filter.hasAnyFilter(), () => messages.aggregateValidations.filterIsAlreadySet(this.operatorName));
    }
    groupIsNotSet(groupBy) {
        return this.addValidation(() => groupBy.length === 0, () => messages.aggregateValidations.groupIsAlreadySet(this.operatorName));
    }
    _isNumber(specifier, operand) {
        return this.addValidation(() => isNumber(operand), () => messages.queryValidations.isNumber(this.operatorName, specifier, operand));
    }
    isPositiveNumber(operand) {
        return this._isNumber('positive', operand).addValidation(() => !Number.isNaN(operand) && operand > 0, () => messages.queryValidations.isPositiveNumber(this.operatorName, operand));
    }
    isNonNegativeNumber(operand) {
        return this._isNumber('non-negative', operand).addValidation(() => !Number.isNaN(operand) && operand >= 0, () => messages.queryValidations.isNonNegativeNumber(this.operatorName, operand));
    }
    isInteger(operand) {
        return this.addValidation(() => !Number.isNaN(operand) &&
            Number.isFinite(operand) &&
            Number.isInteger(operand) &&
            operand < MAX_SAFE_INTEGER &&
            operand > -MAX_SAFE_INTEGER, () => messages.queryValidations.isInteger(this.operatorName, operand));
    }
    typeIsString(value) {
        return this.addValidation(() => isString(value), () => messages.filterValidations.typeIsString(this.operatorName, value));
    }
    typeIsStringIfSet(value) {
        return this.addValidation(() => value === undefined || isString(value), () => messages.filterValidations.typeIsString(this.operatorName, value));
    }
}
//# sourceMappingURL=WixDataAggregateImpl.js.map