import { Mode } from '../../types';
import { QueryValidator } from '../QueryValidator';
import { QueryBase } from '../QueryBase';
export class WixDataSearchImpl extends QueryBase {
    constructor(origin) {
        super(origin);
        this.projectedFields = origin?.projectedFields ?? [];
        this.limitNumber = origin?.limitNumber;
        this.skipNumber = origin?.skipNumber ?? 0;
        this.included = origin?.included ?? [];
        this.ownInvalidArguments = origin.invalidArguments ?? [];
        this.queryText = origin.queryText;
        this.searchMode = origin.searchMode;
        this.isFuzzy = origin.isFuzzy;
        this.onRun = origin.onRun;
    }
    copy(params) {
        return new WixDataSearchImpl({
            ...this,
            filterBuilder: params.filterBuilder ?? this.filterBuilder,
            projectedFields: params.projectedFields ?? this.projectedFields,
            limitNumber: params.limitNumber ?? this.limitNumber,
            skipNumber: params.skipNumber ?? this.skipNumber,
            included: params.included ?? this.included,
            sort: params.sort ?? this.sort,
            invalidArguments: params.invalidArguments ?? this.ownInvalidArguments,
            queryText: params.queryText ?? this.queryText,
            searchMode: params.searchMode ?? this.searchMode,
            isFuzzy: params.isFuzzy ?? this.isFuzzy,
            onRun: this.onRun,
        });
    }
    expression(queryText) {
        return this.copy({ queryText });
    }
    andMode() {
        return this.copy({ searchMode: Mode.AND });
    }
    orMode() {
        return this.copy({ searchMode: Mode.OR });
    }
    fuzzy() {
        return this.copy({ isFuzzy: true });
    }
    run(options) {
        return this.onRun(this.toSearchParams(), options);
    }
    get invalidArguments() {
        return [
            ...this.ownInvalidArguments,
            ...this.filterBuilder.invalidArguments,
            ...this.sort.invalidArguments,
        ];
    }
    toSearchParams() {
        let filterTree;
        try {
            // optimized filter if no errors
            filterTree = this.filterBuilder.build();
        }
        catch (_error) {
            filterTree = this.filterBuilder.filterTree;
        }
        return {
            collectionName: this.collectionName,
            invalidArguments: this.invalidArguments,
            projectedFields: this.projectedFields,
            limitNumber: this.limitNumber,
            skipNumber: this.skipNumber,
            included: this.included,
            filterTree,
            orderBy: this.orderBy,
            queryText: this.queryText,
            searchMode: this.searchMode,
            isFuzzy: this.isFuzzy,
        };
    }
    fields(...fields) {
        return this.copy({
            projectedFields: [...this.projectedFields, ...fields],
        });
    }
    limit(limitNumber) {
        const [invalidArguments] = this.queryValidator('.limit')
            .arityIsOne(arguments)
            .isPositiveNumber(limitNumber)
            .isInteger(limitNumber)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            limitNumber,
        });
    }
    skip(skipNumber) {
        const [invalidArguments] = this.queryValidator('.skip')
            .arityIsOne(arguments)
            .isNonNegativeNumber(skipNumber)
            .isInteger(skipNumber)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            skipNumber,
        });
    }
    include(...args) {
        if (args.length === 0) {
            return this;
        }
        const last = args[args.length - 1];
        const limit = typeof last === 'number' ? last : undefined;
        const expectedFieldNameCount = limit === undefined ? args.length : args.length - 1;
        const newIncludes = args
            .slice(0, expectedFieldNameCount)
            .map((fieldName) => ({
            fieldName: fieldName,
            limit,
        }));
        const [invalidArguments] = args
            .slice(0, expectedFieldNameCount)
            .reduce((validator, value, _, __) => validator.nonEmptyString(value), this.queryValidator('.include'))
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            included: [...this.included, ...newIncludes],
        });
    }
    queryValidator(operatorName, invalidArguments = this.ownInvalidArguments) {
        return new QueryValidator(operatorName, invalidArguments);
    }
}
//# sourceMappingURL=WixDataSearchImpl.js.map