import { QueryValidator } from '../QueryValidator';
import { QueryBase } from '../QueryBase';
export class WixDataQueryImpl extends QueryBase {
    constructor(origin) {
        super(origin);
        this.projectedFields = origin?.projectedFields ?? [];
        this.limitNumber = origin?.limitNumber;
        this.skipNumber = origin?.skipNumber ?? 0;
        this.included = origin?.included ?? [];
        this.onFind = origin.onFind;
        this.onDistinct = origin.onDistinct;
        this.onCount = origin.onCount;
        this.ownInvalidArguments = origin.invalidArguments ?? [];
    }
    copy(params) {
        return new WixDataQueryImpl({
            ...this,
            filterBuilder: params.filterBuilder ?? this.filterBuilder,
            projectedFields: params.projectedFields ?? this.projectedFields,
            limitNumber: params.limitNumber ?? this.limitNumber,
            skipNumber: params.skipNumber ?? this.skipNumber,
            included: params.included ?? this.included,
            sort: params.sort ?? this.sort,
            invalidArguments: params.invalidArguments ?? this.ownInvalidArguments,
            onFind: this.onFind,
            onDistinct: this.onDistinct,
            onCount: this.onCount,
        });
    }
    count(options) {
        return this.onCount(arguments, this.toQueryParams(), options);
    }
    distinct(field, options) {
        return this.onDistinct(arguments, this.toQueryParams(), field, options);
    }
    find(options) {
        return this.onFind(arguments, this.toQueryParams(), options);
    }
    get invalidArguments() {
        return [
            ...this.ownInvalidArguments,
            ...this.filterBuilder.invalidArguments,
            ...this.sort.invalidArguments,
        ];
    }
    toQueryParams() {
        let filterTree;
        try {
            // optimized filter if no errors
            filterTree = this.filterBuilder.build();
        }
        catch (_error) {
            filterTree = this.filterBuilder.filterTree;
        }
        return {
            collectionName: this.collectionName,
            invalidArguments: this.invalidArguments,
            projectedFields: this.projectedFields,
            limitNumber: this.limitNumber,
            skipNumber: this.skipNumber,
            included: this.included,
            filterTree,
            orderBy: this.orderBy,
        };
    }
    fields(...fields) {
        return this.copy({
            projectedFields: [...this.projectedFields, ...fields],
        });
    }
    limit(limitNumber) {
        const [invalidArguments] = this.queryValidator('.limit')
            .arityIsOne(arguments)
            .isPositiveNumber(limitNumber)
            .isInteger(limitNumber)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            limitNumber,
        });
    }
    skip(skipNumber) {
        const [invalidArguments] = this.queryValidator('.skip')
            .arityIsOne(arguments)
            .isNonNegativeNumber(skipNumber)
            .isInteger(skipNumber)
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            skipNumber,
        });
    }
    include(...args) {
        if (args.length === 0) {
            return this;
        }
        const last = args[args.length - 1];
        const limit = typeof last === 'number' ? last : undefined;
        const expectedFieldNameCount = limit === undefined ? args.length : args.length - 1;
        const newIncludes = args
            .slice(0, expectedFieldNameCount)
            .map((fieldName) => ({
            fieldName: fieldName,
            limit,
        }));
        const [invalidArguments] = args
            .slice(0, expectedFieldNameCount)
            .reduce((validator, value, _, __) => validator.nonEmptyString(value), this.queryValidator('.include'))
            .validateAndAggregate();
        return this.copy({
            invalidArguments,
            included: [...this.included, ...newIncludes],
        });
    }
    queryValidator(operatorName, invalidArguments = this.ownInvalidArguments) {
        return new QueryValidator(operatorName, invalidArguments);
    }
}
//# sourceMappingURL=WixDataQueryImpl.js.map