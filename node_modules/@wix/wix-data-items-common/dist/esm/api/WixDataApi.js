import { apiValidator as commonApiValidator, messages, BulkError, wdeValidationError, } from '../errors';
import * as apiTypes from '../types/data-item-types';
import { hasField, isObject, isArray } from '../utils';
import { filterBuilder } from './common';
import { WixDataQueryImpl } from './impl/WixDataQueryImpl';
import { WixDataResultImpl } from './impl/WixDataResultImpl';
import { WixDataAggregateImpl } from './impl/WixDataAggregateImpl';
import { ApiClient } from './ApiClient';
import { WixDataBulkPatchImpl, WixDataPatchImpl } from './impl/WixDataPatchImpl';
import { WixDataSearchImpl } from './impl/WixDataSearchImpl';
export class WixDataApi {
    constructor(clientFactory, allowGet, environment, gridAppId, tracer) {
        this.environment = environment;
        this.gridAppId = gridAppId;
        this.tracer = tracer;
        // NOTE sort method for builder is not implemented
        this.truncate = withArgs(async (args, collectionName, options) => {
            await apiValidator()
                .arity('truncate', args, 1, 2)
                .collectionName(collectionName)
                .options(options)
                .validateAndReject();
            return this.trace('truncate', { collectionName })(async (env) => {
                await this.client.truncateDataItems({
                    ...env,
                    dataCollectionId: collectionName,
                    ...toOptions(options),
                });
            });
        });
        // --- single-item methods ---
        this.get = withArgs(async (args, collectionName, itemId, options) => {
            await apiValidator()
                .arity('get', args, 2, 3)
                .collectionName(collectionName)
                .itemId(itemId)
                .options(options)
                .validateAndReject();
            return this.trace('get', { collectionName, itemId })(async (env) => {
                const { dataItem } = await this.client
                    .getDataItem({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItemId: itemId,
                    ...toReadOptions(options),
                    fields: options?.fields,
                })
                    .catch(recover(ItemDoesNotExistCode, {}));
                return dataItem ? toDataItem(dataItem) : null;
            });
        });
        this.insert = withArgs(async (args, collectionName, item, options) => {
            await apiValidator()
                .arity('insert', args, 2, 3)
                .collectionName(collectionName)
                .item(item, collectionName, false)
                .options(options)
                .validateAndReject();
            warnAboutBrokenFields(item);
            return this.trace('insert', { collectionName })(async (env) => {
                const { dataItem } = await this.client.insertDataItem({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItem: {
                        id: item._id,
                        data: item,
                    },
                    ...toUpdateOptions(options),
                });
                return toDataItem(dataItem);
            });
        });
        this.save = withArgs(async (args, collectionName, item, options) => {
            await apiValidator()
                .arity('save', args, 2, 3)
                .collectionName(collectionName)
                .item(item, collectionName, false)
                .options(options)
                .validateAndReject();
            return this.trace('save', { collectionName })(async (env) => {
                const { dataItem } = await this.client.saveDataItem({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItem: {
                        id: item._id,
                        data: item,
                    },
                    ...toUpdateOptions(options),
                });
                return toDataItem(dataItem);
            });
        });
        this.update = withArgs(async (args, collectionName, item, options) => {
            await apiValidator()
                .arity('update', args, 2, 3)
                .collectionName(collectionName)
                .item(item, collectionName, false)
                .options(options)
                .validateAndReject();
            return this.trace('update', { collectionName })(async (env) => {
                const { dataItem } = await this.client.updateDataItem({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItem: {
                        id: item._id,
                        data: item,
                    },
                    ...toUpdateOptions(options),
                });
                return toDataItem(dataItem);
            });
        });
        this.remove = withArgs(async (args, collectionName, itemId, options) => {
            await apiValidator()
                .arity('remove', args, 2, 3)
                .collectionName(collectionName)
                .itemId(itemId)
                .options(options)
                .validateAndReject();
            return this.trace('remove', { collectionName, itemId })(async (env) => {
                const { dataItem } = await this.client
                    .removeDataItem({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItemId: itemId,
                    ...toOptions(options),
                })
                    .catch(recover(ItemDoesNotExistCode, {}));
                return dataItem ? toDataItem(dataItem) : null;
            });
        });
        this.toFieldModificationApi = (fieldModification) => {
            switch (fieldModification.action) {
                case 'SET_FIELD':
                    return {
                        action: apiTypes.ACTION.SET_FIELD,
                        fieldPath: fieldModification.fieldPath,
                        setFieldOptions: {
                            value: fieldModification.actionOptions,
                        },
                    };
                case 'REMOVE_FIELD':
                    return {
                        action: apiTypes.ACTION.REMOVE_FIELD,
                        fieldPath: fieldModification.fieldPath,
                    };
                case 'INCREMENT_FIELD':
                    return {
                        action: apiTypes.ACTION.INCREMENT_FIELD,
                        fieldPath: fieldModification.fieldPath,
                        incrementFieldOptions: {
                            value: fieldModification.actionOptions,
                        },
                    };
                case 'APPEND_TO_ARRAY':
                    return {
                        action: apiTypes.ACTION.APPEND_TO_ARRAY,
                        fieldPath: fieldModification.fieldPath,
                        appendToArrayOptions: {
                            value: fieldModification.actionOptions,
                        },
                    };
                case 'REMOVE_FROM_ARRAY':
                    return {
                        action: apiTypes.ACTION.REMOVE_FROM_ARRAY,
                        fieldPath: fieldModification.fieldPath,
                        removeFromArrayOptions: {
                            value: fieldModification.actionOptions,
                        },
                    };
                default:
                    throw new Error('Invalid patch action');
            }
        };
        this.patch = (collectionName, itemId) => {
            return new WixDataPatchImpl({
                collectionName,
                itemId,
                onRun: async (_args, patchParams, options) => {
                    const fieldModifications = patchParams.fieldModifications.map(this.toFieldModificationApi);
                    return this.trace('patch', { collectionName })(async (env) => {
                        const result = await this.client.patchDataItem({
                            ...env,
                            dataCollectionId: patchParams.collectionName,
                            patch: {
                                dataItemId: patchParams.itemId,
                                fieldModifications,
                            },
                            ...toPatchOptions(options),
                        });
                        return result.dataItem ? toDataItem(result.dataItem) : null;
                    });
                },
            });
        };
        this.bulkPatch = (collectionName, itemIds) => {
            return new WixDataBulkPatchImpl({
                collectionName,
                itemIds,
                onRun: async (_args, patchParams, options) => {
                    const fieldModifications = patchParams.fieldModifications.map(this.toFieldModificationApi);
                    return this.trace('bulkPatch', { collectionName })(async (env) => {
                        const { results } = await this.client.bulkPatchDataItems({
                            ...env,
                            dataCollectionId: patchParams.collectionName,
                            patches: patchParams.itemIds.map((itemId) => ({
                                dataItemId: itemId,
                                fieldModifications,
                            })),
                            ...toPatchOptions(options),
                        });
                        return toBulkResult(itemIds, results, ['WDE0073']);
                    });
                },
            });
        };
        // --- query, count, distinct ---
        this.query = (collectionName) => {
            const ensureValidQuery = (invalidArgs) => {
                if (invalidArgs.length > 0) {
                    throw wdeValidationError(messages.queryValidations.queryInvalid(collectionName, invalidArgs));
                }
            };
            return new WixDataQueryImpl({
                collectionName,
                onCount: async (args, params, options) => {
                    ensureValidQuery([
                        ...params.invalidArguments,
                        ...apiValidator()
                            .collectionName(collectionName)
                            .arity('count', args, 0, 1)
                            .options(options)
                            .validateAndReturn(),
                    ]);
                    return this.trace('count', { collectionName })(async (env) => {
                        const { totalCount } = await this.client.countDataItems({
                            ...env,
                            dataCollectionId: collectionName,
                            filter: params.filterTree,
                            ...toReadOptions(options),
                        });
                        return totalCount;
                    });
                },
                onDistinct: async (args, params, field, options) => {
                    ensureValidQuery([
                        ...params.invalidArguments,
                        ...apiValidator()
                            .collectionName(collectionName)
                            .arity('distinct', args, 1, 2)
                            .fieldName(field)
                            .options(options)
                            .validateAndReturn(),
                    ]);
                    const order = toSort(params.orderBy).find((o) => o.fieldName === field)?.order;
                    const fetch = (cursorOrOffset, returnTotalCount) => this.trace('distinct', { collectionName, field })(async (env) => {
                        const { distinctValues, pagingMetadata } = await this.client.queryDistinctValues({
                            ...env,
                            dataCollectionId: collectionName,
                            ...toReadOptions(options),
                            ...toPaging(params.limitNumber, cursorOrOffset),
                            ...(isOffset(cursorOrOffset)
                                ? {
                                    fieldName: field,
                                    filter: params.filterTree,
                                    order,
                                    returnTotalCount,
                                }
                                : {}),
                        });
                        return [distinctValues, pagingMetadata];
                    });
                    const [items, paging] = await fetch(params.skipNumber, options?.returnTotalCount);
                    return new WixDataResultImpl(items, paging, fetch, params);
                },
                onFind: async (args, params, options) => {
                    ensureValidQuery([
                        ...params.invalidArguments,
                        ...apiValidator()
                            .collectionName(collectionName)
                            .arity('find', args, 0, 1)
                            .options(options)
                            .validateAndReturn(),
                    ]);
                    const fetch = (cursorOrOffset, returnTotalCount) => this.trace('query', { collectionName })(async (env) => {
                        const { dataItems, pagingMetadata } = await this.client.queryDataItems({
                            ...env,
                            dataCollectionId: collectionName,
                            query: {
                                fields: params.projectedFields,
                                ...toPaging(params.limitNumber, cursorOrOffset),
                                ...(isOffset(cursorOrOffset)
                                    ? {
                                        filter: params.filterTree,
                                        sort: toSort(params.orderBy),
                                    }
                                    : {}),
                            },
                            referencedItemOptions: params.included,
                            ...toReadOptions(options),
                            ...(isOffset(cursorOrOffset) ? { returnTotalCount } : {}),
                        });
                        return [dataItems.map(toDataItem), pagingMetadata];
                    });
                    const [items, paging] = await fetch(params.skipNumber, options?.returnTotalCount);
                    return new WixDataResultImpl(items, paging, fetch, params);
                },
            });
        };
        this.search = (collectionName) => {
            const ensureValidQuery = (invalidArgs) => {
                if (invalidArgs.length > 0) {
                    throw wdeValidationError(messages.queryValidations.queryInvalid(collectionName, invalidArgs));
                }
            };
            return new WixDataSearchImpl({
                collectionName,
                onRun: async (params, options) => {
                    ensureValidQuery([
                        ...params.invalidArguments,
                        ...apiValidator()
                            .collectionName(collectionName)
                            .options(options)
                            .validateAndReturn(),
                    ]);
                    const expression = params.queryText;
                    const fetch = (cursorOrOffset) => this.trace('search', { collectionName, expression })(async (env) => {
                        const request = {
                            ...env,
                            dataCollectionId: collectionName,
                            search: {
                                filter: params.filterTree,
                                sort: toSort(params.orderBy),
                                fields: params.projectedFields,
                                search: {
                                    expression: params.queryText,
                                    fuzzy: params.isFuzzy,
                                    mode: params.searchMode,
                                },
                                ...toPaging(params.limitNumber, cursorOrOffset),
                            },
                            referencedItemOptions: params.included,
                            ...toReadOptions(options),
                        };
                        const { dataItems, pagingMetadata } = await this.client.searchDataItems(request);
                        return [dataItems.map(toDataItem), pagingMetadata];
                    });
                    const [items, paging] = await fetch(params.skipNumber);
                    return new WixDataResultImpl(items, paging, fetch, params);
                },
            });
        };
        // NOTE find method is not implemented
        this.fetch = withArgs(async (args, collectionName, cursor, limit, options) => {
            await apiValidator()
                .arity('fetch', args, 2, 4)
                .collectionName(collectionName)
                .isNonEmptyString(cursor, 'cursor')
                .validateAndReject();
            const fetch = (cursorOrOffset) => this.trace('query', { collectionName })(async (env) => {
                const { dataItems, pagingMetadata } = await this.client.queryDataItems({
                    ...env,
                    dataCollectionId: collectionName,
                    query: {
                        ...toPaging(limit, cursorOrOffset),
                    },
                    ...toReadOptions(options),
                });
                return [dataItems.map(toDataItem), pagingMetadata];
            });
            const [items, paging] = await fetch(cursor);
            return new WixDataResultImpl(items, paging, fetch, {
                limitNumber: limit,
                collectionName,
                skipNumber: 0,
            });
        });
        // --- aggregate ---
        this.aggregate = (collectionName) => {
            return new WixDataAggregateImpl({
                collectionName,
                onRun: async (args, params, options) => {
                    const validationErrors = [
                        ...params.invalidArguments,
                        ...apiValidator()
                            .arity('run', args, 0, 1)
                            .collectionName(collectionName)
                            .options(options)
                            .validateAndReturn(),
                    ];
                    if (validationErrors.length > 0) {
                        throw wdeValidationError(messages.aggregateValidations.aggregateInvalid(collectionName, validationErrors));
                    }
                    const fetch = (cursorOrOffset, returnTotalCount) => this.trace('aggregate', { collectionName })(async (env) => {
                        const toOperation = (field) => field ? { itemFieldName: field } : undefined;
                        const { results, pagingMetadata } = await this.client.aggregateDataItems({
                            ...env,
                            dataCollectionId: collectionName,
                            ...toPaging(params.limitNumber, cursorOrOffset),
                            ...toReadOptions(options),
                            ...(isOffset(cursorOrOffset)
                                ? {
                                    initialFilter: params.filterTree,
                                    aggregation: {
                                        groupingFields: params.groupBy,
                                        operations: params.aggregates.map((a) => ({
                                            resultFieldName: a.name,
                                            average: toOperation(a.avg),
                                            min: toOperation(a.min),
                                            max: toOperation(a.max),
                                            sum: toOperation(a.sum),
                                            itemCount: a.count ? {} : undefined,
                                        })),
                                    },
                                    finalFilter: params.havingTree,
                                    sort: toSort(params.orderBy),
                                    returnTotalCount,
                                }
                                : {}),
                        });
                        return [unwrapAggregationId(results), pagingMetadata];
                    });
                    const [items, paging] = await fetch(params.skipNumber, options?.returnTotalCount);
                    return new WixDataResultImpl(items, paging, fetch, params);
                },
            });
        };
        this.fetchAggregate = withArgs(async (args, collectionName, cursor, limit, options) => {
            await apiValidator()
                .arity('fetchAggregate', args, 2, 4)
                .collectionName(collectionName)
                .isNonEmptyString(cursor, 'cursor')
                .validateAndReject();
            const fetch = (cursorOrOffset) => this.trace('aggregate', { collectionName })(async (env) => {
                const { results, pagingMetadata } = await this.client.aggregateDataItems({
                    ...env,
                    dataCollectionId: collectionName,
                    ...toPaging(limit, cursorOrOffset),
                    ...toReadOptions(options),
                });
                return [unwrapAggregationId(results), pagingMetadata];
            });
            const [items, paging] = await fetch(cursor, true);
            return new WixDataResultImpl(items, paging, fetch, {
                limitNumber: limit,
                skipNumber: 0,
                collectionName,
            });
        });
        // --- bulk methods ---
        this.bulkRemove = withArgs(async (args, collectionName, itemIds, options) => {
            await apiValidator()
                .arity('bulkRemove', args, 2, 3)
                .collectionName(collectionName)
                .itemIds(itemIds, collectionName)
                .bulkRemoveOptions(options)
                .validateAndReject();
            return this.trace('bulkRemove', { collectionName })(async (env) => {
                const { results } = await this.client.bulkRemoveDataItems({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItemIds: itemIds,
                    ...toOptions(options),
                });
                // Non-existing items are skipped and not reported as errors.
                return toBulkResult(itemIds, results, ['WDE0073']);
            });
        });
        this.bulkInsert = withArgs(async (args, collectionName, items, options) => {
            await apiValidator()
                .arity('bulkInsert', args, 2, 3)
                .items(items, collectionName)
                .bulkInsertOptions(options)
                .collectionName(collectionName)
                .validateAndReject();
            return this.trace('bulkInsert', { collectionName, options })(async (appId) => this.runBulkSave(appId, collectionName, items, options, options?.overrideExisting ?? false));
        });
        this.bulkSave = withArgs(async (args, collectionName, items, options) => {
            await apiValidator()
                .arity('bulkSave', args, 2, 3)
                .bulkInsertOptions(options)
                .collectionName(collectionName)
                .items(items, collectionName)
                .validateAndReject();
            return this.trace('bulkSave', { collectionName })(async (env) => this.runBulkSave(env, collectionName, items, options));
        });
        this.bulkUpdate = withArgs(async (args, collectionName, items, options) => {
            await apiValidator()
                .arity('bulkUpdate', args, 2, 3)
                .bulkUpdateOptions(options)
                .collectionName(collectionName)
                .items(items, collectionName)
                .validateAndReject();
            return this.trace('bulkUpdate', { collectionName })(async (env) => {
                const { results } = await this.client.bulkUpdateDataItems({
                    ...env,
                    dataCollectionId: collectionName,
                    dataItems: items.map((data) => ({
                        id: data._id,
                        data,
                    })),
                    ...toOptions(options),
                });
                // Non-existing items are skipped and not reported as errors.
                return toBulkResult(items, results, ['WDE0073']);
            });
        });
        // --- references ---
        this.fetchReferenced = withArgs(async (args, collectionName, cursor, limit, options) => {
            await apiValidator()
                .arity('fetchReferenced', args, 2, 4)
                .isNonEmptyString(cursor, 'cursor')
                .collectionName(collectionName)
                .validateAndReject();
            const fetch = (current) => this.trace('fetchReferenced', { collectionName })(async (env) => {
                const { results, pagingMetadata } = await this.client.queryReferencedDataItems({
                    ...env,
                    ...toPaging(limit, current),
                    ...toReadOptions(options),
                    dataCollectionId: collectionName,
                    fields: options?.fields,
                });
                return [onlyReferencedItems(results), pagingMetadata];
            });
            const [items, paging] = await fetch(cursor);
            return new WixDataResultImpl(items, paging, fetch, {
                collectionName,
                limitNumber: limit,
                skipNumber: 0,
            });
        });
        this.queryReferenced = withArgs(async (args, collectionName, holdingItem, relationshipAttribute, options) => {
            await apiValidator()
                .arity('queryReferenced', args, 3, 4)
                .collectionName(collectionName)
                .referenceParameter(holdingItem)
                .isNonEmptyString(relationshipAttribute, 'relationshipAttribute')
                .options(options)
                .validateAndReject();
            const id = itemId(holdingItem);
            const fetch = (cursorOrOffset, returnTotalCount) => this.trace('queryReferenced', {
                collectionName,
                itemId: id,
                options,
                relationshipAttribute,
            })(async (env) => {
                const { results, pagingMetadata } = await this.client.queryReferencedDataItems({
                    ...env,
                    ...toPaging(options?.limit ?? 50, cursorOrOffset),
                    ...toReadOptions(options),
                    dataCollectionId: collectionName,
                    fields: options?.fields,
                    ...(isOffset(cursorOrOffset)
                        ? {
                            referringItemId: id,
                            referringItemFieldName: relationshipAttribute,
                            order: options?.order === 'asc'
                                ? apiTypes.SortOrder.ASC
                                : options?.order === 'desc'
                                    ? apiTypes.SortOrder.DESC
                                    : undefined,
                            returnTotalCount,
                        }
                        : {}),
                });
                return [onlyReferencedItems(results), pagingMetadata];
            });
            const [items, paging] = await fetch(options?.skip ?? 0, options?.returnTotalCount);
            return new WixDataResultImpl(items, paging, fetch, {
                collectionName,
                limitNumber: options?.limit ?? 50,
                skipNumber: options?.skip ?? 0,
            });
        });
        this.insertReference = withArgs(async (args, collectionName, refsOrAttr, leftOrOpts, right, options) => {
            let refs;
            let opts;
            let argc;
            if (typeof refsOrAttr === 'string') {
                const rights = asArray(right);
                refs = rights.map((r) => ({
                    relationshipName: refsOrAttr,
                    left: leftOrOpts,
                    right: r,
                }));
                opts = options;
                argc = [4, 5];
            }
            else {
                refs = refsOrAttr;
                opts = leftOrOpts;
                argc = [2, 3];
            }
            await apiValidator()
                .arity('insertReference', args, ...argc)
                .collectionName(collectionName)
                .references(refs)
                .options(opts)
                .validateAndReject();
            await this.trace('insertReference', { collectionName })(async (env) => this.client.bulkInsertDataItemReferences({
                ...env,
                dataCollectionId: collectionName,
                dataItemReferences: refs.map((r) => ({
                    referringItemFieldName: r.relationshipName,
                    referringItemId: itemId(r.left),
                    referencedItemId: itemId(r.right),
                })),
                ...toOptions(opts),
            }));
        });
        this.replaceReferences = withArgs(async (args, collectionName, relationshipAttribute, left, right, options) => {
            const rights = asArray(right);
            await apiValidator()
                .arity('replaceReferences', args, 4, 5)
                .collectionName(collectionName)
                .isNonEmptyString(relationshipAttribute, 'relationshipAttribute')
                .referenceParameter(left)
                .referenceParameters(rights)
                .options(options)
                .validateAndReject();
            await this.trace('replaceReferences', {
                collectionName,
                relationshipAttribute,
            })(async (env) => this.client.replaceDataItemReferences({
                ...env,
                dataCollectionId: collectionName,
                referringItemFieldName: relationshipAttribute,
                referringItemId: itemId(left),
                newReferencedItemIds: rights.map(itemId),
                ...toOptions(options),
            }));
        });
        this.removeReference = withArgs(async (args, collectionName, relationshipAttribute, left, right, options) => {
            const rights = asArray(right);
            await apiValidator()
                .arity('removeReference', args, 4, 5)
                .collectionName(collectionName)
                .referenceParameter(left)
                .referenceRemoveParameters(rights)
                .isNonEmptyString(relationshipAttribute, 'relationshipAttribute')
                .options(options)
                .validateAndReject();
            await this.trace('removeReference', {
                collectionName,
                relationshipAttribute,
            })(async (env) => this.client.bulkRemoveDataItemReferences({
                ...env,
                dataCollectionId: collectionName,
                dataItemReferences: rights.map((r) => ({
                    referringItemFieldName: relationshipAttribute,
                    referringItemId: itemId(left),
                    referencedItemId: itemId(r),
                })),
                ...toOptions(options),
            }));
        });
        this.isReferenced = withArgs(async (args, collectionName, relationshipAttribute, left, right, options) => {
            await apiValidator()
                .arity('isReferenced', args, 4, 5)
                .collectionName(collectionName)
                .referenceParameter(left)
                .referenceParameter(right)
                .options(options)
                .validateAndReject();
            return this.trace('isReferenced', {
                collectionName,
                relationshipAttribute,
            })(async (env) => {
                const { isReferenced } = await this.client.isReferencedDataItem({
                    ...env,
                    dataCollectionId: collectionName,
                    referringItemFieldName: relationshipAttribute,
                    referringItemId: itemId(left),
                    referencedItemId: itemId(right),
                    ...toReadOptions(options),
                    consistentRead: options?.consistentRead,
                });
                return isReferenced;
            });
        });
        this.client = new ApiClient(clientFactory, allowGet);
    }
    get wixData() {
        return this;
    }
    get filter() {
        return filterBuilder();
    }
    async runBulkSave(env, collectionName, items, options, overrideExisting = true) {
        const request = {
            ...env,
            dataCollectionId: collectionName,
            dataItems: items.map((data) => ({
                id: data._id,
                data,
            })),
            ...toOptions(options),
        };
        const { results } = await (overrideExisting
            ? this.client.bulkSaveDataItems(request)
            : this.client.bulkInsertDataItems(request));
        const ignoreCodes = overrideExisting ? [] : ['WDE0074'];
        return toBulkResult(items, results, ignoreCodes);
    }
    trace(action, opts) {
        return async (fn) => {
            const gridAppId = await get(this.gridAppId);
            const env = { appId: gridAppId, environment: this.environment };
            if (this.tracer) {
                return this.tracer(`WixDataApi.${action}`, {
                    ...opts,
                    gridAppId,
                    environment: this.environment,
                })(() => fn(env));
            }
            return fn(env);
        };
    }
}
function withArgs(fn) {
    return function (...args) {
        return fn(arguments, ...args);
    };
}
function toPatchOptions(options) {
    return {
        suppressHooks: options?.suppressHooks,
        ...draftsOptions(options?.showDrafts),
    };
}
function toUpdateOptions(options) {
    return {
        ...toOptions(options),
        includeReferencedItems: options?.includeReferences,
    };
}
function toOptions(opts) {
    if (!opts) {
        return undefined;
    }
    const res = {
        suppressHooks: opts.suppressHooks,
        appOptions: opts.appOptions,
        ...draftsOptions(opts?.showDrafts),
    };
    if (Object.entries(res).every((kv) => kv[1] === undefined)) {
        return undefined;
    }
    return res;
}
function toReadOptions(options) {
    return {
        suppressHooks: options?.suppressHooks,
        appOptions: options?.appOptions,
        ...draftsOptions(options?.showDrafts),
        consistentRead: options?.consistentRead,
        language: options?.language,
    };
}
function draftsOptions(showDrafts) {
    return showDrafts !== undefined
        ? { publishPluginOptions: { includeDraftItems: showDrafts } }
        : {};
}
function toDataItem(item) {
    return item.data;
}
function toPaging(limit, cursorOrOffset) {
    return typeof cursorOrOffset === 'string'
        ? {
            cursorPaging: {
                limit,
                cursor: cursorOrOffset,
            },
        }
        : limit !== undefined || cursorOrOffset > 0
            ? {
                paging: {
                    limit,
                    offset: cursorOrOffset,
                },
            }
            : {};
}
function toSort(orderBy) {
    return orderBy.map((fieldOrder) => {
        const [[fieldName, sort]] = Object.entries(fieldOrder);
        const order = sort === 'asc'
            ? apiTypes.SortOrder.ASC
            : sort === 'desc'
                ? apiTypes.SortOrder.DESC
                : undefined;
        return { fieldName, order };
    });
}
async function get(providerOrValue) {
    if (typeof providerOrValue?.get === 'function') {
        return providerOrValue.get();
    }
    return providerOrValue;
}
function recover(code, value) {
    return (error) => {
        if (error instanceof Error &&
            error?.details?.applicationError?.code === code) {
            return Promise.resolve(value);
        }
        return Promise.reject(error);
    };
}
function warnAboutBrokenFields(item) {
    const hasFieldWithDollar = hasField(item, (key) => key.startsWith('$'));
    const hasFieldWithDot = hasField(item, (key) => key.includes('.'));
    if (hasFieldWithDollar) {
        console.error("Data inserted contains field name prefixed with symbol '$'. It is not recommended to use such field names as it will not work with some data operations.");
    }
    if (hasFieldWithDot) {
        console.warn("Data inserted contains field name containing symbol '.'. It is not recommended to use such field names as it will not work with some data operations.");
    }
}
function toBulkResult(request, results, ignoreCodes = []) {
    const errors = results.flatMap((r) => {
        if (r.itemMetadata?.success || !r.itemMetadata?.error) {
            return [];
        }
        if (ignoreCodes.includes(r.itemMetadata.error.code ?? '')) {
            return [];
        }
        return [
            new BulkError(r.itemMetadata.error.description, r.itemMetadata.error.code, request[r.itemMetadata.originalIndex], 'BulkError', r.itemMetadata.originalIndex),
        ];
    });
    const success = results.filter((r) => r.itemMetadata?.success);
    const inserted = success.filter((r) => r.action === apiTypes.BulkActionType.INSERT);
    const updated = success.filter((r) => r.action === apiTypes.BulkActionType.UPDATE ||
        r.action === apiTypes.BulkActionType.PATCH);
    const removed = success.filter((r) => r.action === apiTypes.BulkActionType.DELETE);
    return {
        inserted: inserted.length,
        updated: updated.length,
        removed: removed.length,
        skipped: request.length - errors.length - success.length,
        errors,
        insertedItemIds: inserted.map((r) => r.itemMetadata?.id),
        updatedItemIds: updated.map((r) => r.itemMetadata?.id),
        removedItemIds: removed.map((r) => r.itemMetadata?.id),
    };
}
function unwrapAggregationId(items) {
    // When grouping by one field WixDataService returns value on _id field directly, DataItemService wraps it in an object, i.e.
    // grouping by surname returns {_id: 'Simpson'} in WixDataService vs {_id: {surname: 'Simpson'}} in DataItemService
    // When grouping by more fields, values are kept wrapped.
    return items.map((item) => {
        const id = item._id;
        if (isObject(id)) {
            const [key, ...rest] = Object.keys(id);
            if (rest.length === 0) {
                item._id = id[key];
                return item;
            }
        }
        return item;
    });
}
function onlyReferencedItems(results) {
    return results
        .map((result) => result.dataItem)
        .filter(notEmpty)
        .map(toDataItem);
}
function notEmpty(value) {
    return value != null;
}
function itemId(item) {
    return typeof item === 'string' ? item : item._id;
}
function asArray(xOrXs) {
    return isArray(xOrXs) ? xOrXs : [xOrXs];
}
function isOffset(cursorOrOffset) {
    return typeof cursorOrOffset === 'number';
}
const ItemDoesNotExistCode = 'WDE0073';
function apiValidator() {
    return commonApiValidator(wdeValidationError);
}
//# sourceMappingURL=WixDataApi.js.map