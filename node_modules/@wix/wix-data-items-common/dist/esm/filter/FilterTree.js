import { messages, validationError } from '../errors/errors';
import { isArray, isObject, isString, isDate, isNumber, isBoolean, } from '../utils/type-utils';
const { filterTreeValidations: errors } = messages;
export function validateFilterOrThrow(tree) {
    const failures = validateFilterTree(tree);
    if (failures.length === 0) {
        return true;
    }
    throw validationError(`Invalid filter:${failures.join('\n')}`);
}
export function validateFilterTree(tree, path) {
    if (!isObject(tree)) {
        return [errors.objectType('Filter Model', tree)];
    }
    const collectedErrors = [];
    for (const key of Object.keys(tree)) {
        const value = tree[key];
        const at = join(path, key);
        switch (key) {
            case '$and':
            case '$or':
                if (!isArray(value)) {
                    collectedErrors.push(errors.arrayType(at, value));
                }
                if (isArray(value)) {
                    collectedErrors.push(...value.flatMap((x) => validateFilterTree(x, at)));
                }
                break;
            case '$not':
                if (!isArray(value)) {
                    collectedErrors.push(...validateFilterTree(value, at));
                }
                if (isArray(value) && value.length !== 1) {
                    collectedErrors.push(errors.arrayLength(at, 1, value));
                }
                if (isArray(value) && value.length > 0) {
                    collectedErrors.push(...validateFilterTree(value[0], at));
                }
                break;
            default:
                if (key.startsWith('$')) {
                    collectedErrors.push(`Unexpected operator ${at}`);
                }
                else {
                    collectedErrors.push(...validateOperatorOrValue(value, at));
                }
        }
    }
    return collectedErrors;
}
function validateOperatorOrValue(value, path) {
    if (isObject(value) &&
        !isComparableValue(value) &&
        Object.keys(value).some((op) => op.startsWith('$'))) {
        return validateOperator(value, path);
    }
    return [];
}
function validateOperator(operator, path) {
    if (!isObject(operator)) {
        return [errors.objectType(path, operator)];
    }
    const collectedErrors = [];
    for (const key of Object.keys(operator)) {
        const at = join(path, key);
        const value = operator[key];
        switch (key) {
            case '$eq':
            case '$ne':
                break;
            case '$gt':
            case '$gte':
            case '$lt':
            case '$lte':
                if (!isComparableValue(value)) {
                    collectedErrors.push(errors.comparisonOperatorType(at, value));
                }
                break;
            case '$startsWith':
            case '$endsWith':
            case '$contains':
                if (!isString(value)) {
                    collectedErrors.push(errors.stringOperatorType(at, value));
                }
                break;
            case '$exists':
                if (!isBoolean(value)) {
                    collectedErrors.push(`${at} should be a Boolean`);
                }
                break;
            case '$hasSome':
            case '$hasAll':
            case '$in':
                if (!isArray(value)) {
                    collectedErrors.push(errors.arrayType(at, value));
                }
                if (isArray(value) && !value.every(isComparableValue)) {
                    collectedErrors.push(errors.setOperatorItems(at, value));
                }
                break;
            case '$matches':
                if (!isObject(value)) {
                    collectedErrors.push(errors.objectType(at, value));
                }
                if (isObject(value) && value.ignoreCase !== true) {
                    collectedErrors.push(errors.matchesOperatorIgnoreCase(value));
                }
                if (isObject(value) && !isArray(value.spec)) {
                    collectedErrors.push(errors.arrayType(`${at}.spec`, value.spec));
                }
                if (isArray(value?.spec)) {
                    const validSpec = (spec) => {
                        if (!isObject(spec)) {
                            return false;
                        }
                        if (spec.type === 'anyOf' && spec.value === ' \t\n-') {
                            return true;
                        }
                        return spec.type === 'literal' && isString(spec.value);
                    };
                    const invalid = value.spec.find((x) => !validSpec(x));
                    if (invalid !== undefined) {
                        collectedErrors.push(errors.matchesOperatorSpecItems(invalid));
                    }
                }
                break;
            case '$regex':
                collectedErrors.push(errors.regexNotAllowed());
                break;
            case '$not':
                collectedErrors.push(...validateOperator(value, at));
                break;
            default:
                collectedErrors.push(`Unknown operator ${at}`);
        }
    }
    return collectedErrors;
}
function isComparableValue(x) {
    if (isDate(x) || isString(x) || isNumber(x)) {
        return true;
    }
    return isObject(x) && isString(x.$date) && Object.keys(x).length === 1;
}
function join(prefix, next) {
    return prefix === undefined ? next : `${prefix}.${next}`;
}
//# sourceMappingURL=FilterTree.js.map