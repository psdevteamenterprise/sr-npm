type Primitive = number | string | boolean | bigint | symbol | null | undefined;
type Tags = Record<string, Primitive>;
type Context = Record<string, unknown>;
type Contexts = Record<string, Context | undefined>;

interface SpanContextData {
    traceId: string;
    spanId: string;
}
interface Span {
    spanContext(): SpanContextData;
    end(): void;
}
interface SpanOptions {
    name: string;
    tags?: Tags;
}
interface Breadcrumb {
    type?: string;
    category?: string;
    message: string;
    level?: 'info' | 'warning' | 'error';
    data?: Record<string, unknown>;
}
interface CaptureContext {
    level?: 'info' | 'warning' | 'error';
    tags?: Tags;
    contexts?: Contexts;
}
interface MonitoringClient {
    /**
     * Captures an exception event and sends it to Sentry.
     * @param error The error to capture
     * @param captureContext Optional additional data to attach to the Sentry e vent.
     * @returns the id of the captured Sentry event.
     */
    captureException(error: unknown, captureContext?: CaptureContext): string;
    /**
     * Captures a message event and sends it to Sentry.
     * @param message The message to capture
     * @param captureContext Define the level of the message or pass in additional data to attach to the message.
     * @returns the id of the captured message.
     */
    captureMessage(message: string, captureContext?: CaptureContext): string;
    /**
     * Wraps a function with a span and finishes the span after the function is done. The created span is the active span and will be used as parent by other spans created inside the function, as long as the function is executed while the scope is active.
     * @param spanOptions The options for the span
     * @param callback The function to wrap with a span
     * @returns The return value of the callback
     */
    startSpan<T>(spanOptions: SpanOptions, callback: (span: Span | undefined) => T): T;
    /**
     * Records a new breadcrumb which will be attached to future events.
     * Breadcrumbs will be added to subsequent events to provide more context on user's actions prior to an error or crash.
     * @param breadcrumb The breadcrumb to record.
     */
    addBreadcrumb(breadcrumb: Breadcrumb): void;
}

type HostModule<T, H extends Host$1> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host$1<Environment = unknown> = {
    channel?: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Optional function to get a monitoring client
     */
    getMonitoringClient?: () => MonitoringClient;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type HTTPMethod = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: HTTPMethod;
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A & G | G ? 1 : 2) extends
	(<G>() => G extends B & G | G ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.

// The `Omit` utility type doesn't work when omitting specific keys from objects containing index signatures.

// Consider the following example:

type UserData = {
	[metadata: string]: string;
	email: string;
	name: string;
	role: 'admin' | 'user';
};

// `Omit` clearly doesn't behave as expected in this case:
type PostPayload = Omit<UserData, 'email'>;
//=> type PostPayload = { [x: string]: string; [x: number]: string; }

// In situations like this, `Except` works better.
// It simply removes the `email` key while preserving all the other keys.
type PostPayload = Except<UserData, 'email'>;
//=> type PostPayload = { [x: string]: string; name: string; role: 'admin' | 'user'; }
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host$1<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host$1;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;
declare global {
    /**
     * A global interface to set the exposure toggle for the SDK.
     * @example
     * ```ts
     * declare global {
     *  interface SDKExposureToggle {
     *    alpha: true;
     *  }
     * }
     */
    interface SDKExposureToggle {
    }
}

type WixNamespace = string;
interface Channel<Environment> {
    observeState(callback: (props: unknown, environment: Environment) => unknown): {
        disconnect: () => void;
    } | Promise<{
        disconnect: () => void;
    }>;
}
interface WebsiteChannel extends Channel<unknown> {
    invoke: (args: {
        namespace: WixNamespace;
        method: string;
        args: unknown[];
    }) => Promise<unknown>;
    getAccessToken: () => Promise<string>;
}
type Host<Environment = unknown> = {
    channel: WebsiteChannel;
    environment?: Environment;
};

/**
 * An object used to manage the query segment of the current page's URL.
 * * Get hands-on experience with the URL query parameters on our [Hello Query Parameters](https://dev.wix.com/docs/coding-examples/getting-started/hello-world/hello-query-parameters) example page.
 */
interface QueryParams {
    /**
     * Adds query parameters to the current page's URL.
     *
     * Adds one or more query parameters to the current page's URL.
     *
     *  The `add()` function can only be used when browser
     *  [rendering](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/frontend-code/page-rendering/about-page-rendering) happens,
     *  meaning you can only use it in frontend code after the page is ready.
     *
     *  If a specified key already exists as a query parameter, the
     *  newly specified value will overwrite the key's previous value.
     *
     *  Calling the `add()` function triggers the [`onChange()`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/on-change)
     *  event handler if it has been registered.
     *  > **Note:** To retrieve the page's current query parameters, use the
     *  [`query`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/query) property.
     * @param toAdd - An object containing a key:value pair
     *  for each query parameter to add to the URL, where the object's
     *  keys are the query parameter keys and the object's values
     *  are the corresponding query parameter values.
     * @requiredField toAdd
     */
    add(toAdd: object): Promise<void>;
    /**
     * Removes query parameters from the current page's URL.
     *
     * Removes one or more query parameters to the current page's URL.
     *
     *  The `remove()` function can only be used when browser
     *  [rendering](https://support.wix.com/en/article/velo-about-the-page-rendering-process) happens,
     *  meaning you can only use it in frontend code after the page is ready.
     *
     *  If a specified key does not exist as a query parameter, it
     *  is ignored.
     *
     *  Calling the `remove()` function triggers the [`onChange()`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/on-change)
     *  event handler if it has been registered.
     *  > **Note:** To retrieve the page's current query parameters, use the
     *  [`query`](location.html#query) property.
     * @param toRemove - List of keys to remove.
     * @requiredField toRemove
     */
    remove(toRemove: string[]): Promise<void>;
}
/**
 * Adds query parameters to the current page's URL.
 *
 * Adds one or more query parameters to the current page's URL.
 *
 *  The `add()` function can only be used when browser
 *  [rendering](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/frontend-code/page-rendering/about-page-rendering) happens,
 *  meaning you can only use it in frontend code after the page is ready.
 *
 *  If a specified key already exists as a query parameter, the
 *  newly specified value will overwrite the key's previous value.
 *
 *  Calling the `add()` function triggers the [`onChange()`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/on-change)
 *  event handler if it has been registered.
 *  > **Note:** To retrieve the page's current query parameters, use the
 *  [`query`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/query) property.
 * @param toAdd - An object containing a key:value pair
 *  for each query parameter to add to the URL, where the object's
 *  keys are the query parameter keys and the object's values
 *  are the corresponding query parameter values.
 * @requiredField toAdd
 */
declare function add(toAdd: object): Promise<void>;
/**
 * Removes query parameters from the current page's URL.
 *
 * Removes one or more query parameters to the current page's URL.
 *
 *  The `remove()` function can only be used when browser
 *  [rendering](https://support.wix.com/en/article/velo-about-the-page-rendering-process) happens,
 *  meaning you can only use it in frontend code after the page is ready.
 *
 *  If a specified key does not exist as a query parameter, it
 *  is ignored.
 *
 *  Calling the `remove()` function triggers the [`onChange()`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/on-change)
 *  event handler if it has been registered.
 *  > **Note:** To retrieve the page's current query parameters, use the
 *  [`query`](location.html#query) property.
 * @param toRemove - List of keys to remove.
 * @requiredField toRemove
 */
declare function remove(toRemove: string[]): Promise<void>;

type queryParamsSdkModuleRuntime_QueryParams = QueryParams;
declare const queryParamsSdkModuleRuntime_add: typeof add;
declare const queryParamsSdkModuleRuntime_remove: typeof remove;
declare namespace queryParamsSdkModuleRuntime {
  export { type queryParamsSdkModuleRuntime_QueryParams as QueryParams, queryParamsSdkModuleRuntime_add as add, queryParamsSdkModuleRuntime_remove as remove };
}

type Methods$1<T> = {
    [P in keyof T as T[P] extends Function ? P : never]: T[P];
};
declare const queryParamsRuntime: MaybeContext<HostModule<Methods$1<typeof queryParamsSdkModuleRuntime>, Host> & Methods$1<typeof queryParamsSdkModuleRuntime>>;

/**
 * An object containing information about a location.
 */
interface Location {
    /**
     * Location path.
     * @requiredField path
     */
    path: string;
}
/**
 * An object containing navigation and scrolling options.
 */
interface NavOptions {
    /**
     * Whether the page scrolls to the top when navigating to the specified URL for a Wix page. Defaults to `false`. When `true`, the page remains at the same Y-axis position as the previously-viewed page. This setting does not affect scrolling for external URLs.
     */
    disableScrollToTop?: boolean;
}
/**
 * Handles location change events.
 * @param event - The new location.
 * @requiredField event
 * @servicePath wix-location-frontend.Location
 */
type LocationChangeHandler = (event: Location) => void;

/**
 * Gets the base URL of the current page.
 *
 * Premium sites:
 *  ![Premium site baseUrl](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_baseurl.png "Premium site baseUrl")
 *
 *  Free sites:
 *  ![Free site baseUrl](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_baseurl.png "Free site baseUrl")
 * @readonly
 */
declare function baseUrl(): Promise<string>;
/**
 * Gets the path of the current page's URL.
 *
 * The path for a regular page is after the  [`baseUrl`](https://dev.wix.com/docs/velo/api-reference/wix-location-frontend/base-url)
 * If the page is a dynamic page or router page, the [`prefix`](location/prefix) appears after the base URL, before the path.
 *
 *
 *  Premium sites:
 *  Path for a regular page, without a prefix: ![Premium site path](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_path.png "Premium site path")
 *  Path for a dynamic or router page with a prefix: ![Premium site path](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_path_with_prefix.png "Premium site path with a prefix")
 *
 *  Free sites:
 *   Path for a regular page, without a prefix: ![Free site path](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_path.png "Free site path")
 *   Path for a dynamic or router page with a prefix: ![Free site path](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_path_with_prefix.png "Free site path")
 * @readonly
 */
declare function path(): Promise<string[]>;
/**
 * Gets the prefix of a dynamic page's or router page's URL.
 *
 * Only dynamic pages and router pages have a prefix. The value of the
 *  `prefix` property for other page types is always `undefined`.
 *
 *  Premium sites:
 *  ![Premium site prefix](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_prefix.png "Premium site prefix")
 *
 *  Free sites:
 *  ![Free site prefix](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_prefix.png "Free site prefix")
 *
 *  To learn more about dynamic page prefixes, see [About URL Prefixes and Page Grouping of Dynamic Pages](https://support.wix.com/en/article/about-url-prefixes-and-page-grouping-of-dynamic-pages).
 *
 *  To learn more about router page prefixes, see [About Routers](https://support.wix.com/en/article/about-routers#url-prefix).
 * @readonly
 */
declare function prefix(): Promise<string>;
/**
 * Gets the protocol of the current page's URL.
 *
 * Premium sites:
 *  ![Premium site protocol](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_protocol.png "Premium site protocol")
 *
 *  Free sites:
 *  ![Free site protocol](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_protocol.png "Free site protocol")
 * @readonly
 */
declare function protocol(): Promise<string>;
/**
 * Gets an object that represents the query segment of the current page's URL.
 *
 * Premium sites:
 *  ![Premium site query](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_query.png "Premium site query")
 *
 *  Free sites:
 *  ![Free site query](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_query.png "Free site query")
 * @readonly
 */
declare function query(): Promise<object>;
/**
 * Gets the full URL of the current page.
 *
 * Premium sites:
 *  ![Premium site URL](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_premium_url.png "Premium site URL")
 *
 *  Free sites:
 *  ![Free site URL](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_url_free_url.png "Free site URL")
 * @readonly
 */
declare function url(): Promise<string>;
/**
 * Adds an event handler that runs when an application page's URL changes.
 *
 * The event handler set by the `onChange()` function runs when the location is changed
 * but the change doesn't trigger navigation. This situation occurs when navigating between
 * subitems on a page that is managed by a full-page application.
 *
 * For example, a store product page is a full-page application. When a product page's path
 * changes because it is switching between items, no actual navigation is taking place. You
 * can use the `onChange()` event handler to determine when a new product is displayed and
 * perform any necessary partial updates on the current page.
 *
 * The `onChange()` function can only be used when browser
 * [rendering](https://support.wix.com/en/article/velo-about-the-page-rendering-process) happens,
 * meaning you can only use it in frontend code after the page is ready.
 *
 * To determine if a page is managed by a full-page application, use the `wix-site-frontend`
 * [`currentPage`](https://dev.wix.com/docs/velo/api-reference/wix-site-frontend/current-page) property or [`getSiteStructure()`](https://dev.wix.com/docs/velo/api-reference/wix-site-frontend/get-site-structure)
 * function to retrieve a `StructurePage` object that
 * corresponds to the page. If the object contains an `applicationId` value, then the
 * page is managed by a full-page application.
 * @param handler - The name of the function or
 *  the function expression to run when the location changes.
 * @requiredField handler
 * @servicePath wix-location-frontend.LocationChangeHandler
 */
declare function onChange(handler: LocationChangeHandler): Promise<void>;
/**
 * Directs the browser to navigate to the specified URL.
 *
 * The `to()` function navigates the browser to another web page.
 *
 *  The `to()` function can only be used when browser
 *  [rendering](https://support.wix.com/en/article/velo-about-the-page-rendering-process) happens,
 *  meaning you can only use it in frontend code after the page is ready.
 *
 *  The following link patterns are supported:
 *
 *  + `/localPageURL`: Another page on your site.
 *  + `/localPageURL#`: Another page on your site scrolled to the
 *     element with the specified ID. The element must be an element that supports
 *     the `scrollTo` function.
 *  + `/localPageURL?queryParam=value`: Another page on your site with query parameters.
 *  + `/`: Your site's home page.
 *  + `http(s)://`: An external web address.
 *  + `wix:document://`: A document stored in the Media Manager.
 *  + `mailto:@?subject=`: An email.
 *  + `tel:`: A phone number.
 *
 *
 *  To find the local URL of a page on your site in the Editor:
 *
 *  + Regular page: See the **SEO** tab of the **Page Settings** panel.
 *  + Dynamic page: See the **Page Info** tab of the **Page Settings** panel
 *    for the URL structure. The actual URL used for navigation needs to contain
 *    values where the placeholders are.
 *
 *    For example, if the URL structure of your dynamic page looks like:
 *
 *    ![Dynamic Page URL](https://wixmp-833713b177cebf373f611808.wixmp.com/images/velo-images/media_dynamic_url.png "Dynamic Page URL")
 *
 *    and you have an item with the title "Waffles", the local URL to that page
 *    is /Recipes/Waffles.
 *  + Router page: You cannot navigate directly to a specific router page. You
 *    can navigate to a URL with the router's prefix and the router code
 *    decides which page to route to.
 *
 *  By default, when navigating to a new URL for a Wix page, the page scrolls to the top. Set
 *  the `disableScrollToTop` navigation parameter property to `true` if you want the
 *  page to remain at the current Y-axis position as the previously-viewed page.
 *
 *  The `to()` function attempts to properly encode the URL parameter that
 *  is passed to it. For example, `.../some page` is encoded to
 *  `.../some%20page`. However, some URLs do not have one unambiguous encoding.
 *  In those cases it is up to you to encode the URL to reflect your intentions.
 *  Because of these situations, it is a best practice to always encode URLs
 *  before you pass them to the `to()` function.
 *
 *  Note that Wix URLs do not contain spaces. A page which has spaces in its
 *  name has its spaces replaced with dashes (`-`). Similarly, a dynamic page
 *  whose URL contains the value of a field in your collection with spaces
 *  has its spaces replaced with dashes (`-`).
 *
 *  > **Note:** The `to()` function does not work while previewing your site.
 * @param url - The URL of the page or website to navigate to.
 * @requiredField url
 * @param options - Options to use when navigating to the specified URL, such as scrolling options.
 * @servicePath wix-location-frontend.NavOptions
 */
declare function to(url: string, options?: NavOptions): Promise<void>;

declare const locationSdkModuleRuntime_baseUrl: typeof baseUrl;
declare const locationSdkModuleRuntime_onChange: typeof onChange;
declare const locationSdkModuleRuntime_path: typeof path;
declare const locationSdkModuleRuntime_prefix: typeof prefix;
declare const locationSdkModuleRuntime_protocol: typeof protocol;
declare const locationSdkModuleRuntime_query: typeof query;
declare const locationSdkModuleRuntime_to: typeof to;
declare const locationSdkModuleRuntime_url: typeof url;
declare namespace locationSdkModuleRuntime {
  export { locationSdkModuleRuntime_baseUrl as baseUrl, locationSdkModuleRuntime_onChange as onChange, locationSdkModuleRuntime_path as path, locationSdkModuleRuntime_prefix as prefix, locationSdkModuleRuntime_protocol as protocol, locationSdkModuleRuntime_query as query, locationSdkModuleRuntime_to as to, locationSdkModuleRuntime_url as url };
}

type Methods<T> = {
    [P in keyof T as T[P] extends Function ? P : never]: T[P];
};
declare const locationRuntime: MaybeContext<HostModule<Methods<typeof locationSdkModuleRuntime>, Host> & Methods<typeof locationSdkModuleRuntime>>;

export { locationRuntime as location, queryParamsRuntime as queryParams };
