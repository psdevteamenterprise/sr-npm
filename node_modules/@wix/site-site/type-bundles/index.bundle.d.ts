type Primitive = number | string | boolean | bigint | symbol | null | undefined;
type Tags = Record<string, Primitive>;
type Context = Record<string, unknown>;
type Contexts = Record<string, Context | undefined>;

interface SpanContextData {
    traceId: string;
    spanId: string;
}
interface Span {
    spanContext(): SpanContextData;
    end(): void;
}
interface SpanOptions {
    name: string;
    tags?: Tags;
}
interface Breadcrumb {
    type?: string;
    category?: string;
    message: string;
    level?: 'info' | 'warning' | 'error';
    data?: Record<string, unknown>;
}
interface CaptureContext {
    level?: 'info' | 'warning' | 'error';
    tags?: Tags;
    contexts?: Contexts;
}
interface MonitoringClient {
    /**
     * Captures an exception event and sends it to Sentry.
     * @param error The error to capture
     * @param captureContext Optional additional data to attach to the Sentry e vent.
     * @returns the id of the captured Sentry event.
     */
    captureException(error: unknown, captureContext?: CaptureContext): string;
    /**
     * Captures a message event and sends it to Sentry.
     * @param message The message to capture
     * @param captureContext Define the level of the message or pass in additional data to attach to the message.
     * @returns the id of the captured message.
     */
    captureMessage(message: string, captureContext?: CaptureContext): string;
    /**
     * Wraps a function with a span and finishes the span after the function is done. The created span is the active span and will be used as parent by other spans created inside the function, as long as the function is executed while the scope is active.
     * @param spanOptions The options for the span
     * @param callback The function to wrap with a span
     * @returns The return value of the callback
     */
    startSpan<T>(spanOptions: SpanOptions, callback: (span: Span | undefined) => T): T;
    /**
     * Records a new breadcrumb which will be attached to future events.
     * Breadcrumbs will be added to subsequent events to provide more context on user's actions prior to an error or crash.
     * @param breadcrumb The breadcrumb to record.
     */
    addBreadcrumb(breadcrumb: Breadcrumb): void;
}

type HostModule<T, H extends Host$1> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host$1<Environment = unknown> = {
    channel?: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Optional function to get a monitoring client
     */
    getMonitoringClient?: () => MonitoringClient;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type HTTPMethod = 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: HTTPMethod;
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A & G | G ? 1 : 2) extends
	(<G>() => G extends B & G | G ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.

// The `Omit` utility type doesn't work when omitting specific keys from objects containing index signatures.

// Consider the following example:

type UserData = {
	[metadata: string]: string;
	email: string;
	name: string;
	role: 'admin' | 'user';
};

// `Omit` clearly doesn't behave as expected in this case:
type PostPayload = Omit<UserData, 'email'>;
//=> type PostPayload = { [x: string]: string; [x: number]: string; }

// In situations like this, `Except` works better.
// It simply removes the `email` key while preserving all the other keys.
type PostPayload = Except<UserData, 'email'>;
//=> type PostPayload = { [x: string]: string; name: string; role: 'admin' | 'user'; }
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host$1<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host$1;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;
declare global {
    /**
     * A global interface to set the exposure toggle for the SDK.
     * @example
     * ```ts
     * declare global {
     *  interface SDKExposureToggle {
     *    alpha: true;
     *  }
     * }
     */
    interface SDKExposureToggle {
    }
}

type WixNamespace = string;
interface Channel<Environment> {
    observeState(callback: (props: unknown, environment: Environment) => unknown): {
        disconnect: () => void;
    } | Promise<{
        disconnect: () => void;
    }>;
}
interface WebsiteChannel extends Channel<unknown> {
    invoke: (args: {
        namespace: WixNamespace;
        method: string;
        args: unknown[];
    }) => Promise<unknown>;
    getAccessToken: () => Promise<string>;
}
type Host<Environment = unknown> = {
    channel: WebsiteChannel;
    environment?: Environment;
};

/**
 * Gets how frequently the page is likely to change.
 *
 * The value of the `changeFrequency` property provides general information to
 * search engines and may not correlate exactly to how often they crawl the page.
 *
 * Valid values:
 *
 * + `"always"`
 * + `"hourly"`
 * + `"daily"`
 * + `"weekly"`
 * + `"monthly"`
 * + `"yearly"`
 * + `"never"`
 * @readonly
 */
declare function changeFrequency(): Promise<string>;
/**
 * Gets when the page data was last modified.
 * @readonly
 */
declare function lastModified(): Promise<Date>;
/**
 * Gets the page name.
 * @readonly
 */
declare function pageName(): Promise<string>;
/**
 * Gets the priority of this URL relative to other URLs on your site.
 *
 * The value of the `priority` property lets search engines know which pages
 * you deem most important. Its value does not affect how your pages are
 * compared to pages on other sites.
 *
 * Valid values range from 0.0 to 1.0.
 *
 * The default priority of a page is 0.5.
 * @readonly
 */
declare function priority(): Promise<number>;
/**
 * Gets the page title.
 * @readonly
 */
declare function title(): Promise<string>;
/**
 * Gets the relative url of the page.
 * @readonly
 */
declare function url(): Promise<string>;
/**
 * An object representing a single entry in a sitemap.
 */
interface WixRouterSitemapEntry {
    /**
     * Gets how frequently the page is likely to change.
     *
     * The value of the `changeFrequency` property provides general information to
     * search engines and may not correlate exactly to how often they crawl the page.
     *
     * Valid values:
     *
     * + `"always"`
     * + `"hourly"`
     * + `"daily"`
     * + `"weekly"`
     * + `"monthly"`
     * + `"yearly"`
     * + `"never"`
     * @readonly
     */
    readonly changeFrequency: string;
    /**
     * Gets when the page data was last modified.
     * @readonly
     */
    readonly lastModified: Date;
    /**
     * Gets the page name.
     * @readonly
     */
    readonly pageName: string;
    /**
     * Gets the priority of this URL relative to other URLs on your site.
     *
     * The value of the `priority` property lets search engines know which pages
     * you deem most important. Its value does not affect how your pages are
     * compared to pages on other sites.
     *
     * Valid values range from 0.0 to 1.0.
     *
     * The default priority of a page is 0.5.
     * @readonly
     */
    readonly priority: number;
    /**
     * Gets the page title.
     * @readonly
     */
    readonly title: string;
    /**
     * Gets the relative url of the page.
     * @readonly
     */
    readonly url: string;
}

type wixRouterSitemapEntrySdkModuleRuntime_WixRouterSitemapEntry = WixRouterSitemapEntry;
declare const wixRouterSitemapEntrySdkModuleRuntime_changeFrequency: typeof changeFrequency;
declare const wixRouterSitemapEntrySdkModuleRuntime_lastModified: typeof lastModified;
declare const wixRouterSitemapEntrySdkModuleRuntime_pageName: typeof pageName;
declare const wixRouterSitemapEntrySdkModuleRuntime_priority: typeof priority;
declare const wixRouterSitemapEntrySdkModuleRuntime_title: typeof title;
declare const wixRouterSitemapEntrySdkModuleRuntime_url: typeof url;
declare namespace wixRouterSitemapEntrySdkModuleRuntime {
  export { type wixRouterSitemapEntrySdkModuleRuntime_WixRouterSitemapEntry as WixRouterSitemapEntry, wixRouterSitemapEntrySdkModuleRuntime_changeFrequency as changeFrequency, wixRouterSitemapEntrySdkModuleRuntime_lastModified as lastModified, wixRouterSitemapEntrySdkModuleRuntime_pageName as pageName, wixRouterSitemapEntrySdkModuleRuntime_priority as priority, wixRouterSitemapEntrySdkModuleRuntime_title as title, wixRouterSitemapEntrySdkModuleRuntime_url as url };
}

type Methods$1<T> = {
    [P in keyof T as T[P] extends Function ? P : never]: T[P];
};
declare const wixRouterSitemapEntryRuntime: MaybeContext<HostModule<Methods$1<typeof wixRouterSitemapEntrySdkModuleRuntime>, Host> & Methods$1<typeof wixRouterSitemapEntrySdkModuleRuntime>>;

/**
 * An object that contains information about which pages and lightboxes to
 *  prefetch resources for.
 */
interface PrefetchItems {
    /**
     * The relative or absolute URLs of the pages in your site
     *  to prefetch resources for.
     */
    pages?: string[];
    /**
     * The names of the lightboxes in your site to prefetch
     *  resources for.
     *
     *  > **Note:** Pages are listed by relative or absolute URL, but lightboxes are listed by name.
     *  See [`location.to()`](location.html#to) to learn how to find a page's relative
     *  URL. You can find a lightbox's name by selecting the lightbox and clicking the settings button.
     */
    lightboxes?: string[];
}
/**
 * An object that is returned from a prefetch request.
 */
interface PrefetchResult {
    /**
     * A success or failure message.
     * @requiredField message
     */
    message: string;
    /**
     * The errors that occurred.
     * @requiredField errors
     * @servicePath wix-site-frontend.PrefetchResultError
     */
    errors: PrefetchResultError;
}
/**
 * An object that is returned when a resource prefetch is unsuccessful.
 */
interface PrefetchResultError {
    /**
     * The names of the pages for which prefetch failed.
     * @requiredField pages
     */
    pages: string[];
    /**
     * The names of the lightbox for which prefetch failed.
     * @requiredField lightboxes
     */
    lightboxes: string[];
}
/**
 * An object that contains information about the site's prefixes.
 */
interface Prefix {
    /**
     * The name of the prefix.
     * @requiredField name
     */
    name: string;
    /**
     * The type of the prefix.
     *
     *  A site's routers, dynamic pages, and app pages all have prefixes.
     *
     *  One of:
     *
     *  + `"dynamicPages"`
     *  + `"router"`
     *  + `"app"`
     * @requiredField type
     */
    type: string;
    /**
     * The prefix.
     * @requiredField prefix
     */
    prefix: string;
    /**
     * If the prefix is an app's prefix, the `applicationId` property is the app's ID.
     */
    applicationId?: string;
}
/**
 * An object that contains information about the site's pages, prefixes, and lightboxes.
 */
interface SiteStructure {
    /**
     * The pages of the site.
     *  Pages can be regular pages, dynamic pages, router pages, or pages from an app.
     * @requiredField pages
     * @servicePath wix-site-frontend.StructurePage
     */
    pages: StructurePage[];
    /**
     * The prefixes of the site's routers and dynamic pages.
     * @requiredField prefixes
     * @servicePath wix-site-frontend.Prefix
     */
    prefixes: Prefix[];
    /**
     * The site's lightboxes.
     * @requiredField lightboxes
     * @servicePath wix-site-frontend.StructureLightbox
     */
    lightboxes: StructureLightbox[];
}
/**
 * An object that contains information about a lightbox on the site.
 */
interface StructureLightbox {
    /**
     * The name of the lightbox.
     * @requiredField name
     */
    name: string;
}
/**
 * An object that contains information about a page on the site.
 */
interface StructurePage {
    /**
     * The name of the page.
     * @requiredField name
     */
    name: string;
    /**
     * The type of the page: `"static"` or `"template"`.
     * @requiredField type
     */
    type: string;
    /**
     * The URL of the page. If the page is a `static` page the `url` property is the page's SEO URL.
     */
    url?: string;
    /**
     * If the page is an app page, the `applicationId` property is the app's ID.
     */
    applicationId?: string;
    /**
     * If the page is a router or dynamic page, the `prefix` property is the page's prefix.
     */
    prefix?: string;
    /**
     * If the page is the Home page, `isHomePage` is `true`. Otherwise, it does not exist.
     */
    isHomePage?: boolean;
}
/**
 * The options used when getting the HTML element.
 */
interface getFontsHtmlOptions {
    /**
     * An identifier that is added in a `data-test-id` attribute on the returned HTML element. Use this identifier to locate the HTML element when testing your code.
     * @requiredField testId
     */
    testId: string;
}
/**
 * The options used when getting HTML element.
 */
interface getSiteThemeHtmlOptions {
    /**
     * An identifier that is added in a `data-test-id` attribute on the returned HTML element. You can use this identifier to locate the HTML element when testing your code.
     * @requiredField testId
     */
    testId: string;
}

/**
 * Gets a code representing the site's currency.
 *
 * The retrieved currency code corresponds to the currency that has been
 *  entered in the General Info section of your site's Dashboard.
 *
 *  The currency is used your site, apps (e.g. Wix Stores, Wix Bookings), and other
 *  Wix features.
 * @readonly
 */
declare function currency(): Promise<string>;
/**
 * Gets information about the current page or lightbox.
 * @readonly
 * @servicePath wix-site-frontend.StructurePage
 * @servicePath wix-site-frontend.StructureLightbox
 */
declare function currentPage(): Promise<StructurePage | StructureLightbox>;
/**
 * Gets a code representing the site's language.
 *
 * The retrieved language code corresponds to the main site language
 *  as found in the General Info section of your site's Dashboard.
 *
 *  > **Note:** If you have a multilingual site, and it is being viewed in a language
 *  that is not the main site language, the `language` property still returns
 *  the main site language. To work with the languages of a multilingual site,
 *  use the [Multilingual API](https://dev.wix.com/docs/velo/api-reference/wix-window-frontend/multilingual/introduction).
 * @readonly
 */
declare function language(): Promise<string>;
/**
 * Gets the site's regional settings.
 *
 * The retrieved regional settings corresponds to the regional settings
 *  that has been entered in the General Info section of your site's Dashboard.
 *
 *  The regional settings are used to determine how numbers, dates, and currencies
 *  are displayed on your site.
 * @readonly
 */
declare function regionalSettings(): Promise<string>;
/**
 * Gets the site revision ID.
 *
 * The site revision ID is a unique identifier for the current revision of
 *  your site. Each time you manually save your site or publish your site
 *  following a change, a new revision is created.
 *
 * You can view and manage your site revisions in your [Site History](https://support.wix.com/en/article/viewing-and-managing-your-site-history).
 * You can use [site monitoring](https://support.wix.com/en/article/about-site-monitoring#site-revisions) to
 * monitor and debug new revisions of your site.
 *
 *  > **Notes:**
 *  > + Since publishing your site may change the revision ID, the ID when
 *  >   previewing your site may be different than the ID for the published site.
 * >
 * >
 * > + The site revision ID is guaranteed to be unique, but not meaningful.
 * >   Therefore, you cannot predict future revision IDs before they are created.
 * @readonly
 */
declare function revision(): Promise<string>;
/**
 * Gets the site's timezone.
 *
 * The retrieved timezone is the timezone that has been
 *  entered in the General Info section of your site's Dashboard.
 *
 *  The timezone is used your site, apps (e.g. Wix Stores, Wix Bookings), and other
 *  Wix features.
 * @readonly
 */
declare function timezone(): Promise<string>;
/**
 * Gets an HTML element containing CSS code to load fonts.
 *
 * Use the `getFontsHtml()` function to get an HTML element containing the CSS code that loads one or more fonts.
 * Use this function when embedding a custom element in a Wix site where the page's stylesheet fonts
 * are inaccessible, such as when using a shadow root or an internal iframe.
 * @param fonts - List of fonts to be loaded, where each font is represented by a value of a `font` CSS property.
 * @requiredField fonts
 * @param options - The options used when getting the HTML element.
 * @servicePath wix-site-frontend.getFontsHtmlOptions
 * @returns Fulfilled - HTML element containing the CSS code that loads the fonts.
 */
declare function getFontsHtml(fonts: string[], options?: getFontsHtmlOptions): Promise<string>;
/**
 * Gets the site display name.
 *
 * Retrieves the site display name, which is the name that
 *  has been entered in the **Website Settings** section of the site's [**Dashboard**](https://support.wix.com/en/article/wix-dashboard-overview).
 *
 * @returns The site display name.
 */
declare function getSiteDisplayName(): Promise<string>;
/**
 * Returns information about the site's pages, prefixes, and lightboxes.
 *
 * The returned `SiteStructure` object is a flattened representation of the site.
 *  The structure does not include the headers and links from the site's **Pages** menu.
 *
 * @returns An object that contains information about the site's pages, prefixes, and lightboxes.
 * @servicePath wix-site-frontend.SiteStructure
 */
declare function getSiteStructure(): Promise<SiteStructure>;
/**
 * Gets the CSS code of the site's theme.
 * Use the `getSiteThemeHtml()` function to get an HTML element containing the CSS code of a site's
 * [theme colors and fonts](https://support.wix.com/en/article/wix-editor-customizing-your-sites-theme-and-design).
 * Use this function when embedding a custom element in a Wix site where the page's stylesheet
 * is inaccessible, such as when using a shadow root or an internal iframe.
 * @param options - The options used when getting the HTML element.
 * @servicePath wix-site-frontend.getSiteThemeHtmlOptions
 * @returns Fulfilled - HTML element containing site's theme CSS.
 */
declare function getSiteThemeHtml(options?: getSiteThemeHtmlOptions): Promise<string>;
/**
 * Optimizes resource fetching of pages and lightboxes in the site so they will load faster.
 *
 * Use the `prefetchPageResources()` function to optimize resource fetching of pages and
 *  lightboxes you think your site visitors are likely to visit next. When the site
 *  visitor navigates to those pages or lightboxes, they will load quicker than usual
 *  since some of their resources have already been retrieved.
 *
 *  You can only prefetch resources from pages or lightboxes within the current site.
 *
 *  A prefetch is considered successful if the specified pages and lightboxes exist in
 *  the current site. If any of the specified pages or lightboxes do not exist, the
 *  prefetch operation returns an error status and lists of the pages and lightboxes
 *  that were not found.
 * @param prefetchItems - The items within the site to prefetch resources for.
 * @requiredField prefetchItems
 * @servicePath wix-site-frontend.PrefetchItems
 * @returns Results of a prefetch.
 * @servicePath wix-site-frontend.PrefetchResult
 */
declare function prefetchPageResources(prefetchItems: PrefetchItems): Promise<PrefetchResult>;
/**
 * Returns the sitemap for a router or dynamic page prefix.
 *
 * The `routerSitemap()` function returns a Promise that resolves to a list of
 *  [`WixSitemapEntry`](https://dev.wix.com/docs/velo/api-reference/wix-router/wix-router-sitemap-entry) objects. Each
 *  [`WixSitemapEntry`](https://dev.wix.com/docs/velo/api-reference/wix-router/wix-router-sitemap-entry) includes
 *  information about a page, such as its URL, title, and name.
 *
 *  A sitemap is used by search engines to find the links to the site's pages.
 * @param routerPrefix - The prefix of the router to get the sitemap for.
 * @requiredField routerPrefix
 * @returns Fulfilled - A list of sitemap entries.
 * Rejected - The error that caused the rejection.
 * @servicePath wix-site-frontend.WixRouterSitemapEntry
 */
declare function routerSitemap(routerPrefix: string): Promise<WixRouterSitemapEntry[]>;

declare const siteSdkModuleRuntime_currency: typeof currency;
declare const siteSdkModuleRuntime_currentPage: typeof currentPage;
declare const siteSdkModuleRuntime_getFontsHtml: typeof getFontsHtml;
declare const siteSdkModuleRuntime_getSiteDisplayName: typeof getSiteDisplayName;
declare const siteSdkModuleRuntime_getSiteStructure: typeof getSiteStructure;
declare const siteSdkModuleRuntime_getSiteThemeHtml: typeof getSiteThemeHtml;
declare const siteSdkModuleRuntime_language: typeof language;
declare const siteSdkModuleRuntime_prefetchPageResources: typeof prefetchPageResources;
declare const siteSdkModuleRuntime_regionalSettings: typeof regionalSettings;
declare const siteSdkModuleRuntime_revision: typeof revision;
declare const siteSdkModuleRuntime_routerSitemap: typeof routerSitemap;
declare const siteSdkModuleRuntime_timezone: typeof timezone;
declare namespace siteSdkModuleRuntime {
  export { siteSdkModuleRuntime_currency as currency, siteSdkModuleRuntime_currentPage as currentPage, siteSdkModuleRuntime_getFontsHtml as getFontsHtml, siteSdkModuleRuntime_getSiteDisplayName as getSiteDisplayName, siteSdkModuleRuntime_getSiteStructure as getSiteStructure, siteSdkModuleRuntime_getSiteThemeHtml as getSiteThemeHtml, siteSdkModuleRuntime_language as language, siteSdkModuleRuntime_prefetchPageResources as prefetchPageResources, siteSdkModuleRuntime_regionalSettings as regionalSettings, siteSdkModuleRuntime_revision as revision, siteSdkModuleRuntime_routerSitemap as routerSitemap, siteSdkModuleRuntime_timezone as timezone };
}

type Methods<T> = {
    [P in keyof T as T[P] extends Function ? P : never]: T[P];
};
declare const siteRuntime: MaybeContext<HostModule<Methods<typeof siteSdkModuleRuntime>, Host> & Methods<typeof siteSdkModuleRuntime>>;

export { siteRuntime as site, wixRouterSitemapEntryRuntime as wixRouterSitemapEntry };
