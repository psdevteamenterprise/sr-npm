const { COLLECTIONS } = require('../../public/consts'); // need relative import to not break site due to frontend modules imports inside backend
const { wixData, wixCollections } = require('../elevated-modules');

const { TASK_STATUS, TASK_TYPE, TASK_MAX_TRIES } = require('./consts');

async function createTasksCollectionIfMissing(collectionId) {
  console.log('Checking for collection with ID:', collectionId);
  try {
    // try to get the tasks collection by id, if it doesn't exist, this will throw an error
    await wixCollections.getDataCollection(collectionId);
    console.log('Tasks collection already exists');
  } catch (e) {
    if (e.message.includes('WDE0025')) {
      // an error that indicates that the collection does not exist.
      console.log('Tasks collection does not exist. Creating...');
      await wixCollections.createDataCollection({
        id: collectionId,
        fields: [
          { key: 'name', type: 'TEXT' },
          { key: 'data', type: 'OBJECT' },
          { key: 'type', type: 'TEXT', enum: ['event', 'scheduled'] },
          {
            key: 'status',
            type: 'TEXT',
            enum: ['pending', 'in_progress', 'success', 'skipped', 'failed'],
          },
          { key: 'error', type: 'TEXT' },
          { key: 'amountOfRetries', type: 'NUMBER' },
          {
            key: 'parentTaskId',
            type: 'REFERENCE',
            typeMetadata: { reference: { referencedCollectionId: collectionId } },
          },
          { key: 'Task Result', type: 'TEXT' },
        ],
        permissions: { insert: 'ADMIN', update: 'ADMIN', remove: 'ADMIN', read: 'ADMIN' },
      });
      console.log('Tasks collection created successfully');
    } else {
      //unexpected error
      console.log(
        `while trying to get collection with id: ${collectionId} an unexpected error occurred:${e}`
      );
      throw e;
    }
  }
}

const getTaskConfig = (taskName, tasksConfig) => {
  const taskConfig = Object.values(tasksConfig).find(t => t.name === taskName);
  if (!taskConfig) {
    throw new Error(`unknown task name ${taskName}`);
  }
  return taskConfig;
};

const updateTask = async task => {
  try {
    await wixData.update(COLLECTIONS.TASKS, task);
  } catch (err) {
    const errMsg = `[updateTask] for ${JSON.stringify(task)} failed with error: ${err.message}`;
    console.error(errMsg);
    throw new Error(errMsg);
  }
};
const markTask = async ({ task, status, error, amountOfRetries }) => {
  const toMarkTask = {
    ...task,
    ...(status && { status }),
    ...(error && { error: error.message ?? error }),
    ...(amountOfRetries !== undefined && { amountOfRetries }),
  };
  await updateTask(toMarkTask);
};
const insertNewTask = async ({ name, data, type, parentTaskId }) => {
  await createTasksCollectionIfMissing(COLLECTIONS.TASKS);
  try {
    if (
      typeof name !== 'string' ||
      !name ||
      typeof data !== 'object' ||
      !data ||
      typeof type !== 'string' ||
      !type ||
      (parentTaskId !== undefined && (typeof parentTaskId !== 'string' || !parentTaskId))
    ) {
      throw new Error(
        `[insertNewTask] Invalid params: ${JSON.stringify({ name, data, type, parentTaskId })}`
      );
    }
    console.log('inserting pending task', name);
    const insertedTask = await wixData.insert(COLLECTIONS.TASKS, {
      name,
      parentTaskId,
      data,
      status: TASK_STATUS.PENDING,
      type,
      amountOfRetries: 0,
    });
    console.log(`Task ${name} inserted successfully`);
    return insertedTask._id;
  } catch (err) {
    const errMsg = `[insertNewTask] Failed for Task ${name} with error ${err.message}`;
    console.error(errMsg);
    throw new Error(errMsg);
  }
};
const bulkInsertTasks = async tasks => {
  try {
    const toInsertTasks = tasks.map(task => ({
      ...task,
      status: TASK_STATUS.PENDING,
      amountOfRetries: 0,
    }));
    const insertedTasks = await wixData.bulkInsert(COLLECTIONS.TASKS, toInsertTasks);
    return insertedTasks.insertedItemIds;
  } catch (err) {
    const errMsg = `[bulkInsertTasks] Failed for Tasks with error ${err.message}`;
    console.error(errMsg);
    throw new Error(errMsg);
  }
};

const getExpectedChildTasks = (task, taskConfig) => {
  const childTasks =
    typeof taskConfig.childTasks === 'function'
      ? taskConfig.childTasks(task)
      : taskConfig.childTasks;
  return childTasks;
};
const isParentTask = (task, taskConfig) => {
  if (!('childTasks' in taskConfig)) {
    return false;
  }
  const childTasks = getExpectedChildTasks(task, taskConfig);
  if (!Array.isArray(childTasks) || childTasks.length === 0) {
    throw new Error('taskConfig.childTasks must be a non-empty array if defined');
  }
  return true;
};
const filterScheduledTasksByStatus = (tasks, tasksConfig) => {
  console.log(`filterScheduledTasksByStatus: ${ JSON.stringify(tasks) } ${ JSON.stringify(tasksConfig) }`);
  const filtered = tasks.filter(task => {
    if (task.status === TASK_STATUS.IN_PROGRESS) {
      //Only include parent tasks that are in progress
      console.log(`filterScheduledTasksByStatus: task: ${ JSON.stringify(task) }`);
      console.log(`filterScheduledTasksByStatus: tasksConfig: ${ JSON.stringify(tasksConfig) }`);
      return isParentTask(task, tasksConfig[task.name]);
    }
    return [TASK_STATUS.PENDING, TASK_STATUS.FAILED].includes(task.status);
  });
  console.log(`filterScheduledTasksByStatus: filtered: ${ JSON.stringify(filtered) }`);
  return filtered;
};
const getScheduledTasks = async () => {
  try {
    const baseQuery = wixData.query(COLLECTIONS.TASKS);
    const scheduledTasksQuery = baseQuery
      .eq('type', TASK_TYPE.SCHEDULED)
      .hasSome('status', [TASK_STATUS.PENDING, TASK_STATUS.FAILED, TASK_STATUS.IN_PROGRESS]);
    const eventBasedTasksQuery = baseQuery
      .eq('type', TASK_TYPE.EVENT)
      .eq('status', TASK_STATUS.FAILED);
    return await scheduledTasksQuery
      .or(eventBasedTasksQuery)
      .lt('amountOfRetries', TASK_MAX_TRIES)
      .ascending('_updatedDate')
      .limit(1000)
      .find()
      .then(result => result.items);
  } catch (error) {
    throw new Error(`[getScheduledTasks] failed with error: ${error.message}`);
  }
};
const getTaskScheduledChildren = async parentTaskId => {
  try {
    return await wixData
      .query(COLLECTIONS.TASKS)
      .eq('parentTaskId', parentTaskId)
      .ascending('_createdDate')
      .limit(1000)
      .find()
      .then(result => result.items);
  } catch (error) {
    console.error(
      `[getTaskScheduledChildren] failed for task [${parentTaskId}] with error: ${error.message}`
    );
    throw error;
  }
};

const getTasksToProcess = ({ scheduledTasks, tasksConfig, maxDuration }) => {
  console.log("getTasksToProcess:", { scheduledTasks, tasksConfig, maxDuration })
  const tasksToProcess = [];
  let totalDuration = 0;
  console.log(`tasksConfig is : ${ JSON.stringify(tasksConfig) }`);
  const filteredScheduledTasks = filterScheduledTasksByStatus(scheduledTasks, tasksConfig);
  console.log(`filteredScheduledTasks is  : ${ JSON.stringify(filteredScheduledTasks) }`);
  for (const task of filteredScheduledTasks) {
    console.log(`task is : ${ JSON.stringify(task) }`);
    const taskConfig = getTaskConfig(task.name, tasksConfig);
    console.log(`taskConfig is : ${ JSON.stringify(taskConfig) }`);
    const estimated = taskConfig?.estimatedDurationSec;
    if (!estimated) {
      const errMsg = `[getTasksToProcess] estimatedDurationSec is not defined for task ${task.name}`;
      console.error(errMsg);
      throw new Error(errMsg);
    }
    const buffered = estimated * 1.5; // 1.5x buffer to be safe

    if (totalDuration + buffered > maxDuration) break;
    totalDuration += buffered;
    tasksToProcess.push(task);
  }
  console.log("getTasksToProcess: tasksToProcess:", tasksToProcess)
  return tasksToProcess;
};

module.exports = {
  getTaskConfig,
  updateTask,
  markTask,
  insertNewTask,
  bulkInsertTasks,
  getScheduledTasks,
  getTaskScheduledChildren,
  isParentTask,
  getTasksToProcess,
  getExpectedChildTasks,
};
