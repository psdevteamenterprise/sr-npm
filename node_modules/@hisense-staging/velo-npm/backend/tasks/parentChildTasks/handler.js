const { getTaskConfig, getTaskScheduledChildren, getExpectedChildTasks } = require('../utils');

const { scheduleChildren } = require('./childScheduler');
const {
  hasFailedChildAndMarkedParent,
  hasUnfinishedChild,
  areChildrenSucceededAndMarkedParent,
} = require('./parentStatusManager');
const { shouldScheduleNextChild: _shouldScheduleNextChild } = require('./utils');
const scheduleChildTasksAndUpdateParent = async (task, tasksConfig) => {
  const { _id: parentTaskId, name: parentTaskName, data: parentTaskData } = task;
  const parentTaskConfig = getTaskConfig(parentTaskName, tasksConfig);
  const expectedChildTasks = getExpectedChildTasks(task, parentTaskConfig);
  const scheduledChildren = await getTaskScheduledChildren(parentTaskId);
  const childrenScheduler = scheduleChildren({
    parentTaskId,
    parentTaskData,
    expectedChildTasks,
    scheduledChildren,
  });
  if (!scheduledChildren.length) {
    console.log(
      `No scheduled children found for task with id ${parentTaskId}, started scheduling children`
    );
    if (parentTaskConfig.scheduleChildrenSequentially) {
      console.log('scheduling children sequentially');
      return childrenScheduler.sequentially(0);
    } else {
      console.log('scheduling children in bulk');
      return childrenScheduler.inBulk();
    }
  }

  if (hasUnfinishedChild(scheduledChildren)) {
    console.log(
      `[Children Unfinished]: Found unfinished children for task with id ${parentTaskId}, quitting parent processing`
    );
    return;
  }

  if (await hasFailedChildAndMarkedParent(task, scheduledChildren)) {
    console.log(
      `[Children Failed]: Found Failed children for task with id ${parentTaskId}, quitting parent processing`
    );
    return;
  }

  if (
    await areChildrenSucceededAndMarkedParent({
      parent: task,
      scheduledChildren: scheduledChildren,
      expectedChildrenCount: expectedChildTasks.length,
    })
  ) {
    console.log(
      `[Children Completed Successfully]: All children for task with id ${parentTaskId} completed Successfully, quitting parent processing.`
    );
    return;
  }
  const shouldScheduleNextChild = _shouldScheduleNextChild({
    parentTaskConfig,
    scheduledChildren,
    expectedChildTasks,
  });
  if (shouldScheduleNextChild) {
    const toScheduleChildIndex = scheduledChildren.length;
    console.log(
      `[Sequential Scheduling]: Scheduling child with index ${toScheduleChildIndex} for task with id ${parentTaskId}`
    );
    return childrenScheduler.sequentially(toScheduleChildIndex);
  }
  throw new Error(
    `[scheduleChildTasksAndUpdateParent] - Something went wrong with task: ${task.name} this line should not be reached`
  );
};

module.exports = { scheduleChildTasksAndUpdateParent };
