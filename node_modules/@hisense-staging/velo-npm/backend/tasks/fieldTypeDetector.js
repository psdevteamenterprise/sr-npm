/**
 * Utility functions for detecting field types based on values
 */

/**
 * Checks if a string is a valid URL
 * @param {string} str - The string to check
 * @returns {boolean} - Whether the string is a valid URL
 */
function isValidUrl(str) {
  if (typeof str !== 'string') return false;

  try {
    const url = new URL(str);
    return ['http:', 'https:', 'ftp:', 'ftps:'].includes(url.protocol);
  } catch {
    return false;
  }
}

/**
 * Checks if a string represents a date/datetime
 * @param {string} str - The string to check
 * @returns {boolean} - Whether the string represents a valid date
 */
function isDateString(str) {
  if (typeof str !== 'string') return false;

  // Common date patterns
  const datePatterns = [
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/, // ISO 8601: 2025-06-24T11:26:00.000Z
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}[+-]\d{2}:\d{2}$/, // ISO with timezone: 2025-06-24T11:26:00+01:00
    /^\d{4}-\d{2}-\d{2}$/, // Date only: 2025-06-24
    /^\d{2}\/\d{2}\/\d{4}$/, // US format: 06/24/2025
    /^\d{2}-\d{2}-\d{4}$/, // Alternative format: 24-06-2025
  ];

  if (!datePatterns.some(pattern => pattern.test(str))) {
    return false;
  }

  // Validate that it's actually a valid date
  const date = new Date(str);
  return !isNaN(date.getTime());
}

/**
 * Checks if a string represents an email address
 * @param {string} str - The string to check
 * @returns {boolean} - Whether the string is a valid email
 */
function isEmail(str) {
  if (typeof str !== 'string') return false;

  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailPattern.test(str);
}

/**
 * Checks if a string represents a phone number
 * @param {string} str - The string to check
 * @returns {boolean} - Whether the string looks like a phone number
 */
function isPhoneNumber(str) {
  if (typeof str !== 'string') return false;

  // Remove all non-alphanumeric characters for pattern matching
  const cleanStr = str.replace(/[\s().-]/g, '');

  // Basic phone number patterns (international and common formats)
  const phonePatterns = [
    /^\+\d{1,3}\d{6,14}$/, // International: +1234567890
    /^\d{10}$/, // Simple 10 digits: 1234567890
    /^\d{11}$/, // 11 digits with country code: 11234567890
  ];

  // Also check original string for formatted patterns
  const formattedPatterns = [
    /^\+\d{1,3}\s?\(\d{3}\)\s?\d{3}[\s-]?\d{4}$/, // +1 (555) 123-4567
    /^\(\d{3}\)\s?\d{3}[\s-]?\d{4}$/, // (555) 123-4567
    /^\d{3}[\s-]?\d{3}[\s-]?\d{4}$/, // 555-123-4567 or 555 123 4567
    /^\+\d{1,3}[\s-]?\d{6,14}$/, // +1-1234567890 or +1 1234567890
  ];

  return (
    phonePatterns.some(pattern => pattern.test(cleanStr)) ||
    formattedPatterns.some(pattern => pattern.test(str))
  );
}

/**
 * Detects the appropriate Wix Data field type based on a value
 * @param {*} value - The value to analyze
 * @returns {string} - The Wix Data field type
 */
function detectFieldType(value) {
  // Handle null/undefined
  if (value === null || value === undefined) {
    return 'TEXT'; // Default to TEXT for null values
  }

  // Handle primitive types first
  if (typeof value === 'boolean') {
    return 'BOOLEAN';
  }

  if (typeof value === 'number') {
    return 'NUMBER';
  }

  if (value instanceof Date) {
    return 'DATETIME';
  }

  // Handle arrays
  if (Array.isArray(value)) {
    return 'ARRAY';
  }

  // Handle objects (but not arrays or dates)
  if (typeof value === 'object') {
    return 'OBJECT';
  }

  // Handle strings with special patterns
  if (typeof value === 'string') {
    // Check for empty strings
    if (value.trim() === '') {
      return 'TEXT';
    }

    // Check for date strings first (most specific)
    if (isDateString(value)) {
      return 'DATETIME';
    }

    // Check for URLs
    if (isValidUrl(value)) {
      return 'URL';
    }

    // Check for email addresses
    if (isEmail(value)) {
      return 'EMAIL';
    }

    // Check for phone numbers
    if (isPhoneNumber(value)) {
      return 'PHONE';
    }

    // Check for very long text (might be better as rich text)
    if (value.length > 500) {
      return 'RICHTEXT';
    }

    // Default to TEXT for other strings
    return 'TEXT';
  }

  // Fallback for unknown types
  return 'TEXT';
}

/**
 * Analyzes multiple values to determine the best field type
 * Useful when you have an array of values and want to determine the most appropriate type
 * @param {Array} values - Array of values to analyze
 * @returns {string} - The most appropriate Wix Data field type
 */
function detectFieldTypeFromMultipleValues(values) {
  if (!Array.isArray(values) || values.length === 0) {
    return 'TEXT';
  }

  // Filter out null/undefined values for analysis
  const validValues = values.filter(v => v !== null && v !== undefined);

  if (validValues.length === 0) {
    return 'TEXT';
  }

  // Get types for all valid values
  const types = validValues.map(detectFieldType);
  const uniqueTypes = [...new Set(types)];

  // If all values have the same type, use that type
  if (uniqueTypes.length === 1) {
    return uniqueTypes[0];
  }

  // Handle mixed types - prioritize more specific types
  const typePriority = {
    BOOLEAN: 8,
    NUMBER: 7,
    DATETIME: 6,
    URL: 5,
    EMAIL: 4,
    PHONE: 3,
    ARRAY: 2,
    OBJECT: 2,
    RICHTEXT: 1,
    TEXT: 0,
  };

  // Find the highest priority type that appears
  const sortedTypes = uniqueTypes.sort((a, b) => (typePriority[b] || 0) - (typePriority[a] || 0));

  // If we have mixed primitive types with TEXT, prefer the more specific type
  // unless it's a very small percentage of the data
  const primaryType = sortedTypes[0];
  const primaryTypeCount = types.filter(t => t === primaryType).length;
  const primaryTypePercentage = primaryTypeCount / types.length;

  // If the primary type represents at least 70% of the data, use it
  if (primaryTypePercentage >= 0.7) {
    return primaryType;
  }

  // Otherwise, default to TEXT for mixed data
  return 'TEXT';
}

module.exports = {
  isValidUrl,
  isDateString,
  isEmail,
  isPhoneNumber,
  detectFieldType,
  detectFieldTypeFromMultipleValues,
};
