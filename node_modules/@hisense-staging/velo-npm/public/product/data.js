const { items: wixData } = require('@wix/data');
const { auth } = require('@wix/essentials');
const { COLLECTIONS } = require('../consts');
const { queryAllItems,getAllItems } = require('../data');
const { withSuccessRateLogs } = require('../logging/success-rate-methods'); //using relative import as this file methods are used in host sites backend

function getQuery(collectionId, elevate = false) {
  if (elevate) {
    return auth.elevate(wixData.query)(collectionId);
  }
  return wixData.query(collectionId);
}

async function getStoresProduct({
  identifier,
  value,
  includeHiddenProducts = false,
  includeCollections = false,
}) {
  const baseQuery = getStoresBaseQuery({
    elevate: includeHiddenProducts,
    identifier,
    value,
    includeCollections,
  });

  const { items } = await baseQuery.limit(1).find({
    omitTotalCount: true,
    ...(includeHiddenProducts && {
      appOptions: { includeHiddenProducts: true },
    }),
  });

  if (items.length === 0) {
    console.info('Product not found on this page');
    return;
  }
  return items[0];
}

function getStoresBaseQuery({ elevate = false, identifier, value, includeCollections = false }) {
  const query = getQuery(COLLECTIONS.STORE_PRODUCTS, elevate);
  let baseQuery = query.eq(identifier, value);

  if (includeCollections) {
    baseQuery = baseQuery.include('collections');
  }

  return baseQuery;
}

async function getProductInCMSByProductInStores(product) {
  const productInCMSResult = await wixData
    .query(COLLECTIONS.CMS_PRODUCTS)
    .limit(2) // limit should be 2 for the error below to make sense
    .eq('storeProduct', product._id)
    .include('storeSiblings', 'supportDocuments')
    .find({ omitTotalCount: true });
  if (productInCMSResult.items.length !== 1) {
    throw new Error(
      `found ${productInCMSResult.items.length} products in CMS with storeProduct ${product._id}. there should be only 1 mathicng product`
    );
  }
  const productInCMS = productInCMSResult.items[0];
  return productInCMS;
}

async function getProductInCMS({ identifier, value, includeHiddenProducts = false, includeCollections = false },notFoundError=true) {
  const product = await getStoresProduct({ identifier, value, includeHiddenProducts, includeCollections });
  if (!product ) {
    if(notFoundError){
      throw new Error(`Product with identifier ${value} doesn't exist , args: ${JSON.stringify(arguments)}`);
    }
    return null;
  }
  const productInCMS = await getProductInCMSByProductInStores(product)
  return { productInCMS, product }
}

async function getStoreProductByIds(storeProductIds) {
  const storeProducts = await wixData
    .query(COLLECTIONS.STORE_PRODUCTS)
    .hasSome('_id', storeProductIds)
    .find({ omitTotalCount: true });

  return storeProducts.items;
}

async function getDataBySlug(slug) {
  const product = await getStoresProduct({ identifier: 'slug', value: slug });
  if (!product) {
    throw new Error(`Product with slug ${slug} doesn't exist`);
  }
  const productInCMS = await getProductInCMSByProductInStores(product);
  const siblings = productInCMS['storeSiblings'];
  return { product, productInCMS, siblings };
}

function getSpecsOfProduct(idOfProductInCms) {
  return wixData
    .query(COLLECTIONS.SPECS)
    .eq('product', idOfProductInCms)
    .limit(1000)
    .find({ omitTotalCount: true });
}

async function getCompiledDataBySlug(slug) {
  const compiledData = await wixData.query(COLLECTIONS.COMPILED_PRODUCTS).eq('slug', slug).find();
  if (compiledData.items.length > 0) {
    return compiledData.items[0].ProductData;
  }
}
async function getAllPhysicalProducts() {
  const productsDataQuery = wixData.query(COLLECTIONS.STORE_PRODUCTS).eq('productType', 'physical');
  return await queryAllItems(productsDataQuery);
}


async function fillCompiledProduct(){
  const storesProducts  = await getAllItems(COLLECTIONS.STORE_PRODUCTS)
  let count = 0;
  for (const storesProduct of storesProducts) {
      const slug = storesProduct.slug;
      try {
          await refreshDataBySlug(slug);
          console.log(`updated data for slug: ${slug}. Progress: ${++count}/${storesProducts.length}`);
      } catch (e) {
          console.error(`Failed to refresh data for slug: ${slug}`, e);
      }
  }


async function refreshDataBySlug(slug) {
    // the getDataBySlug method is reused in the ProductPage code. 
    // Meaning if we compile the results of that method in the compiled products collection
    // the render of the product page will be able to rely on the compiled data without having 
    // to run the getDataBySlug (which could be slow) during the render process.
    const refreshedData = await getDataBySlug(slug); 
    const newDataToUpdate = {
            slug: slug,
            ProductData: refreshedData
    }

    const compiledProductResult = await getCompiledDataBySlug(slug);
    if(compiledProductResult) {
        newDataToUpdate._id = compiledProductResult._id;
    }

    await wixData.save(COLLECTIONS.COMPILED_PRODUCTS, newDataToUpdate);
  
}

}

module.exports = {
  getStoresBaseQuery,
  getStoresProduct: (...args) =>
    withSuccessRateLogs('getStoresProduct', () => getStoresProduct(...args)),
  getProductInCMSByProductInStores: (...args) =>
    withSuccessRateLogs('getProductInCMSByProductInStores', () =>
      getProductInCMSByProductInStores(...args)
    ),
  getProductInCMS: (...args) =>
    withSuccessRateLogs('getProductInCMS', () =>
      getProductInCMS(...args)
    ),
  getStoreProductByIds: (...args) =>
    withSuccessRateLogs('getStoreProductByIds', () => getStoreProductByIds(...args)),
  getDataBySlug: (...args) => withSuccessRateLogs('getDataBySlug', () => getDataBySlug(...args)),
  getSpecsOfProduct: (...args) =>
    withSuccessRateLogs('getSpecsOfProduct', () => getSpecsOfProduct(...args)),
  getCompiledDataBySlug: (...args) =>
    withSuccessRateLogs('getCompiledDataBySlug', () => getCompiledDataBySlug(...args)),
  getAllPhysicalProducts: (...args) =>
    withSuccessRateLogs('getAllPhysicalProducts', () =>
      getAllPhysicalProducts(...args)
    ),
    fillCompiledProduct: (...args) =>
    withSuccessRateLogs('fillCompiledProduct', () =>
      fillCompiledProduct(...args)
    ),

};
