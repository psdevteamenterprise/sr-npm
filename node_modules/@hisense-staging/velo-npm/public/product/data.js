const { items: wixData } = require('@wix/data');
const { auth } = require('@wix/essentials');

const { COLLECTIONS } = require('../consts');
const { queryAllItems, getAllItems } = require('../data');
const { withSuccessRateLogs } = require('../logging/success-rate-methods'); //using relative import as this file methods are used in host sites backend

function getQuery(collectionId, elevate = false) {
  if (elevate) {
    return auth.elevate(wixData.query)(collectionId);
  }
  return wixData.query(collectionId);
}

async function getStoresProduct({
  identifier,
  value,
  includeHiddenProducts = false,
  includeCollections = false,
}) {
  const baseQuery = getStoresBaseQuery({
    elevate: includeHiddenProducts,
    identifier,
    value,
    includeCollections,
  });

  const { items } = await baseQuery.limit(1).find({
    omitTotalCount: true,
    ...(includeHiddenProducts && {
      appOptions: { includeHiddenProducts: true },
    }),
  });

  if (items.length === 0) {
    console.info('Product not found on this page');
    return;
  }
  return items[0];
}

function getStoresBaseQuery({ elevate = false, identifier, value, includeCollections = false }) {
  const query = getQuery(COLLECTIONS.STORE_PRODUCTS, elevate);
  let baseQuery = query.eq(identifier, value);

  if (includeCollections) {
    baseQuery = baseQuery.include('collections');
  }

  return baseQuery;
}

async function getProductInCMSByProductInStores(product, isTaskFlow = false) {
  const productInCMSResult = await wixData
    .query(COLLECTIONS.CMS_PRODUCTS)
    .limit(2) // limit should be 2 for the error below to make sense
    .eq('storeProduct', product._id)
    .include('storeSiblings', 'supportDocuments')
    .find({ omitTotalCount: true });
  const errorMsg = `Found ${productInCMSResult.items.length} products in CMS with storeProduct ${product._id}. Expected exactly 1 matching product.`;
  if (productInCMSResult.items.length === 0) {
    if (isTaskFlow) {
      console.warn(errorMsg);
    } else {
      throw new Error(errorMsg);
    }
  }
  if (productInCMSResult.items.length >= 2) {
    throw new Error(errorMsg);
  }

  return productInCMSResult.items[0];
}

async function getProductInCMS(
  { identifier, value, includeHiddenProducts = false, includeCollections = false },
  notFoundError = true
) {
  const product = await getStoresProduct({
    identifier,
    value,
    includeHiddenProducts,
    includeCollections,
  });
  if (!product) {
    if (notFoundError) {
      throw new Error(
        `Product with identifier ${value} doesn't exist , args: ${JSON.stringify(arguments)}`
      );
    }
    return null;
  }
  const productInCMS = await getProductInCMSByProductInStores(product);
  return { productInCMS, product };
}

async function getStoreProductByIds(storeProductIds) {
  const storeProducts = await wixData
    .query(COLLECTIONS.STORE_PRODUCTS)
    .hasSome('_id', storeProductIds)
    .find({ omitTotalCount: true });

  return storeProducts.items;
}

async function getDataBySlug(slug, isTaskFlow = false) {
  const product = await getStoresProduct({ identifier: 'slug', value: slug });
  if (!product) {
    throw new Error(`Product with slug ${slug} doesn't exist`);
  }
  const productInCMS = await getProductInCMSByProductInStores(product, isTaskFlow);
  const siblings = productInCMS['storeSiblings'];
  return { product, productInCMS, siblings };
}

function getSpecsOfProduct(idOfProductInCms) {
  return wixData
    .query(COLLECTIONS.SPECS)
    .eq('product', idOfProductInCms)
    .limit(1000)
    .find({ omitTotalCount: true });
}

async function getCompiledDataBySlug(slug) {
  const compiledData = await wixData.query(COLLECTIONS.COMPILED_PRODUCTS).eq('slug', slug).find();
  if (compiledData.items.length > 0) {
    return compiledData.items[0].ProductData;
  }
}
async function getAllPhysicalProducts() {
  const productsDataQuery = wixData.query(COLLECTIONS.STORE_PRODUCTS).eq('productType', 'physical');
  return await queryAllItems(productsDataQuery);
}

async function fillCompiledProduct() {
  const storesProducts = await getAllItems(COLLECTIONS.STORE_PRODUCTS);
  let count = 0;
  for (const storesProduct of storesProducts) {
    const slug = storesProduct.slug;
    try {
      await refreshDataBySlug(slug);
      console.log(`updated data for slug: ${slug}. Progress: ${++count}/${storesProducts.length}`);
    } catch (e) {
      console.error(`Failed to refresh data for slug: ${slug}`, e);
    }
  }
}

async function getSlug(task) {
  const storesProduct = await wixData.get(COLLECTIONS.STORE_PRODUCTS, task.data.storeProductId);
  return storesProduct.slug;
}

async function getSingleCompiledProductBySlug(slug) {
  const compiledProductResult = await wixData
    .query(COLLECTIONS.COMPILED_PRODUCTS)
    .eq('slug', slug)
    .limit(2) // performance improvenemt but we should never have more than 1 the way this module is structured
    .find({ omitTotalCount: true });
  if (compiledProductResult.items.length > 1) {
    throw new Error(`More than one compiled product found for slug ${slug}`);
  }
  return compiledProductResult.items[0]; // items[0] will return null if no items are found
}

async function refreshDataBySlug(slug, isTaskFlow = false) {
  const refreshedData = await getDataBySlug(slug, isTaskFlow);
  const newDataToUpdate = {
    slug: slug,
    ProductData: refreshedData,
  };

  const compiledProductResult = await getSingleCompiledProductBySlug(slug);
  if (compiledProductResult) {
    newDataToUpdate._id = compiledProductResult._id;
  }

  await wixData.save(COLLECTIONS.COMPILED_PRODUCTS, newDataToUpdate);
}
async function deleteCompiledProductBySlug(slug) {
  const compiledProductResult = await getSingleCompiledProductBySlug(slug);
  if (compiledProductResult) {
    await wixData.remove(COLLECTIONS.COMPILED_PRODUCTS, compiledProductResult._id);
  }
}

async function getSlug(task) {
  const storesProduct = await wixData.get(
    COLLECTIONS.STORE_PRODUCTS,
    task.data.storeProductId
  );
  return storesProduct.slug;
}

async function getSlugAndProductId(task) {
  let slug = null;
  if (task.data.storeProductId) {
    slug = await getSlug(task)
  }

  return {slug: slug, productId: task.data.productId};
}


module.exports = {
  getStoresBaseQuery,
  getStoresProduct: (...args) =>
    withSuccessRateLogs('getStoresProduct', () => getStoresProduct(...args)),
  getProductInCMSByProductInStores: (...args) =>
    withSuccessRateLogs('getProductInCMSByProductInStores', () =>
      getProductInCMSByProductInStores(...args)
    ),
  getProductInCMS: (...args) =>
    withSuccessRateLogs('getProductInCMS', () => getProductInCMS(...args)),
  getStoreProductByIds: (...args) =>
    withSuccessRateLogs('getStoreProductByIds', () => getStoreProductByIds(...args)),
  getDataBySlug: (...args) => withSuccessRateLogs('getDataBySlug', () => getDataBySlug(...args)),
  getSpecsOfProduct: (...args) =>
    withSuccessRateLogs('getSpecsOfProduct', () => getSpecsOfProduct(...args)),
  getCompiledDataBySlug: (...args) =>
    withSuccessRateLogs('getCompiledDataBySlug', () => getCompiledDataBySlug(...args)),
  getAllPhysicalProducts: (...args) =>
    withSuccessRateLogs('getAllPhysicalProducts', () => getAllPhysicalProducts(...args)),
  getSlug: (...args) => withSuccessRateLogs('getSlug', () => getSlug(...args)),
  getSlugAndProductId: (...args) => withSuccessRateLogs('getSlugAndProductId', () => getSlugAndProductId(...args)),
  refreshDataBySlug: (...args) =>
    withSuccessRateLogs('refreshDataBySlug', () => refreshDataBySlug(...args)),
  deleteCompiledProductBySlug: (...args) =>
    withSuccessRateLogs('deleteCompiledProductBySlug', () => deleteCompiledProductBySlug(...args)),
  fillCompiledProduct: (...args) =>
    withSuccessRateLogs('fillCompiledProduct', () => fillCompiledProduct(...args)),
};
