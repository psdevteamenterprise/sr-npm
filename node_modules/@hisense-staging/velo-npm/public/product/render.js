const { location } = require('@wix/site-location');
const { seo } = require('@wix/site-seo');
const { site } = require('@wix/site-site');
const { window } = require('@wix/site-window');

const { isElementExistOnPage } = require('../dom.js');
const { withSuccessRateLogs } = require('../logging');
const { withWarmUpData, withMemoization } = require('../performance');
const { logUrlPath } = require('../utils.js');

const {
  getDataBySlug: _getDataBySlug,
  getCompiledDataBySlug,
  getSpecsOfProduct,
} = require('./data.js');
const { isKitchenPackage } = require('./utils.js');

const SUPPORT_PATH = '/support/';

const STATE = {
  slug: '',
};

async function renderProduct(_$w, logger, useOnClickOnSiblings = false) {
  logUrlPath();
  STATE.slug = (await location.path()).pop();
  logger.log(`rendering product with slug: ${STATE.slug}`);
  await renderProductBySlug(STATE.slug, logger);

  async function getDataBySlugOptimized(slug, logger) {
    logger.log(`NPM: using compiled by default`);
    const compiled = await withWarmUpData(
      'getCompiledDataBySlug',
      () => getCompiledDataBySlug(slug),
      logger.log
    );
    if (compiled) {
      logger.log(`found compiled data for slug: ${slug}`);
      return compiled;
    }
    logger.log(`no compiled data found for slug: ${slug}`);
    const nonOptimized = await withWarmUpData(
      'getDataBySlug using NPM',
      () => _getDataBySlug(slug),
      logger.log
    );
    return nonOptimized;
  }

  async function renderProductBySlug(slug, logger) {
    const { log, warn } = logger;
    const monitoredGetDataBySlugOptimized = (...args) =>
      withSuccessRateLogs('getDataBySlugOptimized', () => getDataBySlugOptimized(...args));

    let product, productInCMS, siblings;

    try {
      ({ product, productInCMS, siblings } = await monitoredGetDataBySlugOptimized(slug, logger));
    } catch (error) {
      if (error.message.includes(`Product with slug ${slug} doesn't exist`)) {
        const [baseUrl, query] = await Promise.all([location.baseUrl(), location.query()]);
        const url = new URL(`${baseUrl}/404`);
        addQueryParamsToUrl(url, query);
        console.log('navigating to:', url.toString());
        await location.to(url.toString());
      }
      throw error;
    }

    const productSku = product.sku;

    if (!productSku) {
      throw new Error('Product SKU not found');
    }

    const handleProductInfoSection = () => {
      const handleProductInfo = () => {
        const productInfo = [
          { selector: '#SKUText', property: 'text', value: productSku },
          { selector: '#title', property: 'text', value: product.name },
          {
            selector: '#productProGallery',
            property: 'items',
            value: product.mediaItems,
          },
          { selector: '#productSku', property: 'text', value: productSku },
          {
            selector: '#colorOptionText',
            property: 'text',
            value: product.productOptions?.Color?.choices[0]?.description,
          },
        ];
        productInfo.forEach(({ selector, property, value }) => {
          isElementExistOnPage(_$w(selector)) && (_$w(selector)[property] = value);
        });
      };
      const handleRibbon = () => {
        const ribbon = product.ribbon;
        const ribbonBox = _$w('#ribbonBox');
        const ribbonText = _$w('#ribbonText');
        if (!isElementExistOnPage(ribbonBox) || !isElementExistOnPage(ribbonText)) {
          warn('[handleRibbon]: Ribbon Elements not found!');
          return;
        }
        ribbon ? (ribbonText.text = ribbon) : ribbonBox.delete();
      };
      handleProductInfo();
      handleRibbon();
    };
    const handlePSButtons = () => {
      [_$w('#psBtnWidget0'), _$w('#psBtnWidget1'), _$w('#psBtnWidget2')].forEach(($elem, index) => {
        if (isElementExistOnPage($elem)) {
          const designPresetValue = $elem.id.endsWith('0') ? '1' : `${index}`;
          $elem.setAttribute('design-preset', designPresetValue);
          $elem.setAttribute('ps-sku', productSku);
          $elem.setAttribute('class', 'ps-widget');
        }
      });
    };
    handleProductInfoSection();
    handlePSButtons();
    setNavigationBarButtons(product.slug, productInCMS, log);
    handleResources(productInCMS, warn);
    loadProductSizes({ siblings, product, productInCMS, logger });
    const monitoredHandleSEO = (...args) =>
      withSuccessRateLogs('handleSEO', () => handleSEO(...args));
    await Promise.allSettled([
      monitoredHandleSEO(product),
      handleKitchenPackage(product, productInCMS, log),
    ]);
  }

  async function handleKitchenPackage(product, productInCMS, log) {
    if (isKitchenPackage(product.name)) {
      _$w('#SKUText').hide();
      _$w('#description').show();
      _$w('#description').html = product.description;
    } else {
      isElementExistOnPage(_$w('#description')) && _$w('#description').hide();
      await initProductSpecification(productInCMS, log);
    }
  }

  function handleResources(productInCMS, warn) {
    const $repeater = _$w('#resourcesRepeater');

    if (!$repeater.rendered) {
      warn('[handleResources] Repeater not found');
      return;
    }

    const resources = productInCMS.supportDocuments || [];
    resources.push(`${SUPPORT_PATH}${STATE.slug}`);

    _$w('#resourcesRepeater').onItemReady(($item, itemData) => {
      const link = itemData.link;

      $item('#singleResourceButton').label = link.startsWith(SUPPORT_PATH)
        ? 'Support'
        : decodeURIComponent(link.split('/').pop());
      $item('#singleResourceButton').link = link;
      $item('#singleResourceButton').target = link.startsWith(SUPPORT_PATH) ? '_self' : '_blank';
    });
    _$w('#resourcesRepeater').data = resources.map((resource, index) => ({
      link: resource,
      _id: index.toString(),
    }));
  }

  async function handleSEO(product) {
    const productName = product.name;
    const siteName = await site.getSiteDisplayName();
    const title = `${productName} | ${siteName}`;

    await Promise.all([
      seo.setTitle(title),
      seo.setMetaTags([
        { property: 'og:title', content: title },
        { name: 'twitter:title', content: title },
      ]),
    ]);
  }

  function loadProductSizes({ siblings, product, logger }) {
    const { info } = logger;

    if (siblings.length === 0) {
      info('No siblings found for product');
      if (isElementExistOnPage(_$w('#sizesBox'))) {
        if (typeof _$w('#sizesBox').collapse === 'function') {
          _$w('#sizesBox').collapse();
        } else {
          console.error(`sizesBox ${_$w('#sizesBox')} is not a collapsible element!!`);
        }
      }
      return;
    }

    const existingIndex = siblings.findIndex(sibling => sibling._id === product._id);

    product.isCurrentProduct = true;

    if (existingIndex !== -1) {
      siblings[existingIndex] = product;
    } else {
      siblings.push(product);
    }

    const getSizeByName = name => {
      const extractSizeFromName = name => {
        const match = name?.match(/\d+/);
        return match ? match[0] : null;
      };
      const formatSize = size => {
        if (size) {
          return size.trim();
        }
        return null;
      };
      return formatSize(extractSizeFromName(name));
    };

    siblings = siblings.filter(sibling => typeof sibling === 'object' && sibling !== null);

    siblings.sort((a, b) => {
      const sizeA = getSizeByName(a.name);
      const sizeB = getSizeByName(b.name);
      return parseInt(sizeA) - parseInt(sizeB);
    });

    _$w('#sizesRpt').onItemReady(($item, itemData) => {
      const size = getSizeByName(itemData.name);
      $item('#sizeBtn').label = `${size}"`;

      if (useOnClickOnSiblings) {
        $item('#sizeBtn').onClick(async () => {
          const [baseUrl, path, query] = await Promise.all([
            location.baseUrl(),
            location.path(),
            location.query(),
          ]);
          const url = new URL(`${baseUrl}/${path[0]}/${itemData.slug}`);
          addQueryParamsToUrl(url, query);
          location.to(url.toString());
        });
      } else {
        $item('#sizeBtn').link = `/product-page/${itemData.slug}`;
      }

      if (isElementExistOnPage(_$w('#colorOptionText'))) {
        const itemColor = itemData.productOptions?.Color?.choices[0]?.description;
        if (itemColor) {
          $item('#sizeBtn').style.backgroundColor = itemColor.toLowerCase();
        }
      }

      if (itemData.isCurrentProduct) {
        $item('#sizeBtn').disable();
      }
    });

    _$w('#sizesRpt').data = siblings;
    _$w('#sizesBox').expand();
  }

  function initNavigateToSpecsBtn(productInCMS, log) {
    const $navigateToSpecsBtn = _$w('#navigateToSpecs');
    const $specificationsSection = _$w('#productSpecificationSection');
    if (!$specificationsSection.rendered || !$specificationsSection.isVisible) {
      if (typeof $navigateToSpecsBtn.collapse === 'function') {
        $navigateToSpecsBtn.collapse();
      } else {
        console.error(`navigateToSpecsBtn ${$navigateToSpecsBtn} is not a collapsible element!!`);
      }
    }

    $navigateToSpecsBtn.onClick(async () => {
      await toggleSpecs(productInCMS, log);
    });
  }

  function initNavigateWhereToBuyBtn() {
    if (isElementExistOnPage(_$w('#readyToBuySection'))) {
      const scrollToReadyToBuy = () => _$w('#readyToBuySection').scrollTo();
      if (isElementExistOnPage(_$w('#whereToBuy'))) {
        _$w('#whereToBuy').onClick(scrollToReadyToBuy);
      }
      if (isElementExistOnPage(_$w('#whereToBuyFromLinksMenu'))) {
        _$w('#whereToBuyFromLinksMenu').onClick(scrollToReadyToBuy);
      }
    }
  }

  function initNavigateToOverviewBtn() {
    const $navigateToOverviewBtn = _$w('#navigateToOverview');
    isElementExistOnPage($navigateToOverviewBtn) &&
      $navigateToOverviewBtn.onClick(() => {
        window.scrollTo(0, 0);
      });
  }

  function initNavigateToSupportBtn(slug) {
    const $navigateToSupportBtn = _$w('#navigateToSupport');
    isElementExistOnPage($navigateToSupportBtn) &&
      ($navigateToSupportBtn.link = `${SUPPORT_PATH}${slug}`);
  }

  function setNavigationBarButtons(slug, productInCMS, log) {
    initNavigateToSpecsBtn(productInCMS, log);
    initNavigateToOverviewBtn();
    initNavigateToSupportBtn(slug);
    initNavigateWhereToBuyBtn();
  }

  // specs
  function groupSpecificationsBySubheader(data) {
    const subHeaderOrdersMap = data.reduce((acc, item) => {
      const { subheader, subheaderOrder } = item;
      acc[subheader] = subheaderOrder;
      return acc;
    }, {});

    const grouped = data.reduce((acc, item) => {
      const { subheader, term, details, termOrder } = item;
      if (!acc[subheader]) {
        acc[subheader] = { title: subheader, items: [] };
      }
      acc[subheader].items.push({ title: term, value: details, termOrder });
      acc[subheader].items.sort((a, b) => a.termOrder - b.termOrder);
      return acc;
    }, {});

    return Object.values(grouped).sort(
      (a, b) => subHeaderOrdersMap[a.title] - subHeaderOrdersMap[b.title]
    );
  }

  async function initProductSpecification(productInCMSResult, log) {
    const productSpecification = _$w('#productSpecification');
    await productSpecification.hide();
    if (typeof productSpecification.collapse === 'function') {
      productSpecification.collapse();
    } else {
      console.error(`productSpecification ${productSpecification} is not a collapsible element!!`);
    }

    const btn = _$w('#productSpecificationBtn');
    btn.label = 'Full Specs';
    btn.onClick(() => toggleSpecs(productInCMSResult, log));
  }

  async function loadSpecsAndSetData(productInCMSResult, log) {
    const productSpecification = _$w('#productSpecification');

    const specsOfProduct = await withMemoization(
      'getGroupedSpecsOfProduct',
      () => getGroupedSpecsOfProduct(productInCMSResult),
      log
    );
    if (specsOfProduct.length === 0) {
      return;
    }
    productSpecification.items = specsOfProduct;
  }

  function validateSpecs(specs) {
    const requiredFields = ['details', 'subheader', 'termOrder', 'term', 'subheaderOrder'];

    specs.forEach((spec, index) => {
      requiredFields.forEach(field => {
        if (!spec[field] && spec[field] !== 0) {
          throw new Error(
            `Validation Error: Missing or invalid "${field}" in spec at index ${index}`
          );
        }
      });
    });
  }

  async function getGroupedSpecsOfProduct(productInCMSResult) {
    const specsOfProduct = await getSpecsOfProduct(productInCMSResult._id);
    const items = specsOfProduct.items;
    if (items.length === 0) {
      return [];
    }
    validateSpecs(items);
    items.sort((a, b) => a.subheaderOrder - b.subheaderOrder);
    const grouped = groupSpecificationsBySubheader(items);
    return grouped;
  }

  let areSpecsCurrentlyHidden = true;
  async function toggleSpecs(productInCMSResult, log) {
    const productSpecificationSection = _$w('#productSpecificationSection');
    const productSpecification = _$w('#productSpecification');
    const btn = _$w('#productSpecificationBtn');
    const animConf = { direction: 'top', duration: 300 };
    if (areSpecsCurrentlyHidden) {
      loadSpecsAndSetData(productInCMSResult, log);
      btn.label = 'Hide Specs';
      productSpecification.expand();
      productSpecification.show('roll', animConf);
      productSpecificationSection.scrollTo();
    } else {
      btn.label = 'Full Specs';
      await productSpecification.hide('roll', animConf);
      if (typeof productSpecification.collapse === 'function') {
        productSpecification.collapse();
      } else {
        console.error(
          `productSpecification ${productSpecification} is not a collapsible element!!`
        );
      }
      productSpecificationSection.scrollTo();
    }
    areSpecsCurrentlyHidden = !areSpecsCurrentlyHidden;
  }

  function addQueryParamsToUrl(url, query) {
    if (query) {
      Object.entries(query).forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });
    }
  }
}
module.exports = {
  renderProduct,
};
